package FlowGrid

import ClosureTimers
import Interpolation
import FramePos
import LinkedList

/*
 * FlowGrid: A simple animated grid layout with FramePos tracking.  
 * 
 * Features:  
 * - Top-left origin defined in relative coords (`originX`, `originY`).  
 * - Items flow left â†’ right, wrapping after `cols` columns.  
 * - Use `layoutInstant()` after setup to place items.  
 * - Use `layoutAnimated(duration)` after add/remove for smooth movement.  
 * - Supports optional container frames for grouping items visually.  
 * - Active animations can be globally cancelled.  
*/

/** Global registry of all active grid animations (periodic timers). */
public constant activePeriodicTimers = new LinkedList<CallbackPeriodic>()


/** Cancel and clear all ongoing grid animations. */
public function cancelGridAnimations()
    for t in activePeriodicTimers
        destroy t
    activePeriodicTimers.clear()

/** 
 * SimpleGrid: An animated grid with optional container.  
 * 
 * - `originX`, `originY`: top-left corner of the grid (relative coordinates).  
 * - `cols`: number of columns before wrapping to a new row.  
 * - `cellW`, `cellH`: width and height of each cell.  
 * - `gapX`, `gapY`: spacing between cells.  
 * - `items`: list of frames currently inside the grid.  
 * - `containerFrame`: optional parent frame.  
 * - `useContainer`: true if frames are auto-parented to `containerFrame`.  
 */
public class SimpleGrid
    int layoutGen = 0
    real originX
    real originY
    real cellW
    real cellH
    real gapX
    real gapY
    int cols
    constant items = new LinkedList<framehandle>()
    framehandle containerFrame = null
    boolean useContainer = false

    /** Create a new grid at (originX, originY). */
    construct(real originX, real originY, int cols, real cellW, real cellH, real gap)
        this.originX = originX
        this.originY = originY
        this.cols    = cols
        this.cellW   = cellW
        this.cellH   = cellH
        this.gapX    = gap
        this.gapY    = gap

    /** Optionally create a container frame for grouping grid items. */
    function createContainer(framehandle parent) returns framehandle
        containerFrame = createFrame("FRAME", "GridContainer", parent, null, 0)
        useContainer = true
        return containerFrame

    /** Add a frame to the grid. Will be re-parented to container if available. */
    function add(framehandle f)
        items.add(f)
        if containerFrame != null
            f.setParent(containerFrame)

    /** Remove a frame from the grid. */
    function remove(framehandle f)
        items.remove(f)

    /** Insert a frame at the given index (0 = first). */
    function insert(int index, framehandle f)
        if index <= 0
            items.addAt(f, 0)
        else if index >= items.size()
            items.add(f)
        else
            items.addAt(f, index)

        if containerFrame != null
            f.setParent(containerFrame)

    /** Compute grid position of an item index as (x, y). */
    function indexPos(int idx) returns vec2
        let col = idx % cols
        let row = idx div cols
        let x = originX + col * (cellW + gapX)
        let y = originY - row * (cellH + gapY)
        return vec2(x, y)

    /** Place all items instantly (no animation). */
    function layoutInstant()
        var i = 0
        for f in items
            let pos = indexPos(i)
            if containerFrame != null
                setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, pos.x, pos.y)
            else
                setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, pos.x, pos.y)
            i++

    /** Animate all items into their slots over a duration (seconds). */
    function layoutAnimated(real duration)
        this.layoutGen++                  // invalidate all older animations
        let gen = this.layoutGen
        var i = 0
        for f in items
            animateToIndex(f, i, duration, gen)
            i++

    function animateToIndex(framehandle f, int idx, real duration, int gen)
        let targetPos = indexPos(idx)
        var start = getPos(f)

        let col = idx % cols
        let row = idx div cols

        // New frames: spawn at row head (alpha 0)
        if start == null
            let spawnX = originX
            let spawnY = originY - row * (cellH + gapY)
            BlzFrameSetAlpha(f, 0)
            if containerFrame != null
                setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, spawnX, spawnY)
            else
                setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, spawnX, spawnY)
            // First column: appear instantly
            if col == 0
                if containerFrame != null
                    setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
                else
                    setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
                BlzFrameSetAlpha(f, 255)
                return
            start = getPos(f)

        // If duration is tiny, just snap
        if duration <= 0.0
            if containerFrame != null
                setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
            else
                setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
            BlzFrameSetAlpha(f, 255)
            return

        let dx = (targetPos.x - start.x).abs()
        let dy = (targetPos.y - start.y).abs()
        if dx < 0.001 and dy < 0.001
            BlzFrameSetAlpha(f, 255)
            return

        let steps = max(12, (duration * 12.0).toInt())
        let dt = duration / steps.toReal()
        var iter = 0

        let cb = doPeriodically(dt) (CallbackPeriodic cb) ->
            if gen == this.layoutGen
                iter++
                let t = iter.toReal() / steps.toReal()
                let easedT = easeOutQuart(t)

                let nx = linear(start.x, targetPos.x, easedT)
                let ny = linear(start.y, targetPos.y, easedT)

                if containerFrame != null
                    setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, nx, ny)
                else
                    setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, nx, ny)

                // Fade with the same easing as motion (looks nicer)
                let curAlpha = BlzFrameGetAlpha(f)
                if curAlpha < 255
                    var a = (255.0 * easedT).toInt()
                    if a > 255
                        a = 255
                    BlzFrameSetAlpha(f, a)

                if iter >= steps
                    if containerFrame != null
                        setRelativePointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
                    else
                        setAbsPointTracked(f, FRAMEPOINT_TOPLEFT, targetPos.x, targetPos.y)
                    BlzFrameSetAlpha(f, 255)
                    destroy cb
                    activePeriodicTimers.remove(cb)
            else
                // Newer layout started -> stop this one
                destroy cb
                activePeriodicTimers.remove(cb)

        // Track so cancelGridAnimations() can kill all running animations
        activePeriodicTimers.add(cb)

    /** Quartic ease-out function for smooth deceleration. */
    function easeOutQuart(real t) returns real
        let oneMinusT = 1.0 - t
        return 1.0 - oneMinusT * oneMinusT * oneMinusT * oneMinusT

    /** Total width of the grid (including gaps). */
    function getGridWidth() returns real
        return cols.toReal() * cellW + (cols - 1).toReal() * gapX

    /** Total height of the grid (including gaps). */
    function getGridHeight() returns real
        let totalItems = items.size()
        let rows = (totalItems + cols - 1) div cols
        return rows.toReal() * cellH + (rows - 1).toReal() * gapY