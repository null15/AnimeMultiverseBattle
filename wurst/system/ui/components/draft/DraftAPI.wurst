package DraftAPI

import TableLayout
import GridTableWrapper
import LinkedList
import HashMap

/* 
 * Core draft setup system.  
 * Handles hero registration, player UI state,  
 * category/page buttons, and refreshing the hero grid. 
*/

/** Standard button size (heroes). */
public real heroIconSize = 0.059
/** Larger button size (e.g. featured heroes). */
public real sizeBig = 0.05
/** Smaller button size (compact layout). */
public real categoryPageSize = 0.035

public constant int MAX_CATEGORIES = 8
public constant int MAX_PAGES = 3
constant int PER_PAGE = 30   // heroes per page

/** Per-player draft UI state. */
HashMap<int, DraftUIState> uiState = new HashMap<int, DraftUIState>()

/** Global list of all registered heroes (draft pool). */
LinkedList<HeroDraft> allHeroes = new LinkedList<HeroDraft>()

/** Lookup from hero id â†’ HeroDraft. */
HashMap<int, HeroDraft> heroById = new HashMap<int, HeroDraft>()

/** Text labels used for category buttons. */
public CategoryType array categoryName

/** References to category buttons (1..MAX_CATEGORIES). */
public framehandle array categoryBtns   

/** References to page buttons (1..MAX_PAGES). */
public framehandle array pageBtns       

/** Grid wrapper containing hero buttons. */
public GridCell heroGrid = null

/** Frames currently visible in the grid (local player only). */
public LinkedList<framehandle> shownNow = new LinkedList<framehandle>()

/** 
 * Per-player draft UI state.  
 * Stores which categories are selected,  
 * current page index, and max page available. 
 */
class DraftUIState
    LinkedList<CategoryType> categories
    int currentPage
    int maxPage

    construct()
        categories = new LinkedList<CategoryType>()
        currentPage = 1
        maxPage = 1

public enum CategoryType
    STRENGTH
    AGILITY
    INTELLIGENCE
    BRUISER
    CARRY
    SUPPORT
    MELEE
    RANGE

/** 
 * Hero draft entry.  
 * Wraps hero metadata (id, name, franchise, ranged flag, categories)  
 * and stores a reference to the button frame. 
 */
public class HeroDraft
    int unitID
    string name
    string aftername
    string franchise
    LinkedList<CategoryType> categories
    framehandle btn

    construct()
        this.unitID = 0
        this.name = ""
        this.aftername = ""
        this.franchise = ""
        this.categories = new LinkedList<CategoryType>()
        this.btn = null

    construct(int unitID, string name, string aftername, string franchise)
        this.unitID = unitID
        this.name = name
        this.aftername = aftername
        this.franchise = franchise
        this.categories = new LinkedList<CategoryType>()
        this.btn = btn(name)..setHeight(heroIconSize)..setWidth(heroIconSize)

    /** Returns hero full name (name + aftername if present). */
    function fullName() returns string
        if aftername != ""
            return name + " " + aftername
        return name

    /** Adds Category to chosen hero, up to 30 categories. */
    function addCategory(vararg CategoryType categories) returns LinkedList<CategoryType>
        for category in categories
            this.categories.add(category)
        return this.categories

    /** 
    * Register a hero into the draft pool.  
    * Creates its button, wraps it in HeroDraft,  
    * and inserts into global lists and lookup maps. 
    */
    function addHero(int unitID, string name, string aftername, string franchise)
        this.unitID = unitID
        this.name = name
        this.aftername = aftername
        this.franchise = franchise
        this.btn = btn(name)..setHeight(heroIconSize)..setWidth(heroIconSize)
        allHeroes.add(this)
        heroById.put(this.unitID, this)

/** 
 * Ensure a DraftUIState exists for a player.  
 * Creates and inserts one if missing. 
 */
public function getOrCreateState(int pid) returns DraftUIState
    let st = uiState.get(pid)
    if st == null
        let ns = new DraftUIState()
        uiState.put(pid, ns)
        return ns
    return st

/** 
 * Checks if hero matches all selected categories.  
 * Empty selection always matches. 
 */
public function matchesAll(HeroDraft h, LinkedList<CategoryType> selected) returns bool
    if selected.isEmpty()
        return true
    for cat in selected
        if not h.categories.has(cat)
            return false
    return true

/** Count heroes matching filters for a player. */
public function countFiltered(int pid) returns int
    let st = getOrCreateState(pid)
    var n = 0
    for h in allHeroes
        if matchesAll(h, st.categories)
            n++
    return n

/** Clamp a page number into range [1..maxP]. */
public function clampPage(int page, int maxP) returns int
    if page < 1
        return 1
    if page > maxP
        return maxP
    return page

/** 
 * Update enabled/disabled state of page buttons for a player.  
 * Runs locally (per player). 
 */
public function updatePageButtons(int pid)
    let st = getOrCreateState(pid)
    if GetLocalPlayer() == Player(pid)
        for i = 1 to MAX_PAGES
            if pageBtns[i] != null
                if i <= st.maxPage
                    BlzFrameSetEnable(pageBtns[i], true)
                else
                    BlzFrameSetEnable(pageBtns[i], false)

/** 
 * Refresh hero grid for a player.  
 * Steps:  
 *  - Filter heroes by categories.  
 *  - Slice heroes by page.  
 *  - Update grid: hide old, show new.  
 *  - Run animated layout transition. 
 */
public function refreshGrid(int pid)
    let st = getOrCreateState(pid)
    let total = countFiltered(pid)

    var maxP = (total + PER_PAGE - 1) div PER_PAGE
    if maxP < 1
        maxP = 1
    st.maxPage = maxP
    st.currentPage = clampPage(st.currentPage, st.maxPage)

    updatePageButtons(pid)

    if GetLocalPlayer() != Player(pid)
        return

    let filtered = new LinkedList<HeroDraft>()
    for h in allHeroes
        if matchesAll(h, st.categories)
            filtered.add(h)

    let startIdx = (st.currentPage - 1) * PER_PAGE
    let endIdx = startIdx + PER_PAGE - 1

    let shouldShow = new LinkedList<framehandle>()
    var idx = 0
    for h in filtered
        if idx >= startIdx and idx <= endIdx
            shouldShow.add(h.btn)
        idx++

    // remove old
    for f in shownNow
        if not shouldShow.has(f)
            heroGrid.remove(f)
            BlzFrameSetVisible(f, false)

    // add new
    for f in shouldShow
        if not shownNow.has(f)
            BlzFrameSetVisible(f, true)
            heroGrid.add(f)

    shownNow.clear()
    for f in shouldShow
        shownNow.add(f)

    heroGrid.layoutAnimated(0.20)

/** 
 * Wire category buttons to filtering logic.  
 * Clicking toggles category in/out, resets to page 1, and refreshes grid. 
 */
public function wireCategoryButtons()
    for i = 1 to MAX_CATEGORIES
        if categoryBtns[i] != null
            let idx = i
            categoryBtns[idx].onClick() -> 
                let pid = GetPlayerId(GetTriggerPlayer())
                let st = getOrCreateState(pid)
                let cname = categoryName[idx]
                if st.categories.has(cname)
                    st.categories.remove(cname)
                else
                    st.categories.add(cname)
                st.currentPage = 1
                refreshGrid(pid)

/** 
 * Wire page buttons to change pages.  
 * Ignores clicks if target page is greater than maxPage. 
 */
public function wirePageButtons()
    for i = 1 to MAX_PAGES
        if pageBtns[i] != null
            let idx = i
            pageBtns[idx].onClick() -> 
                let pid = GetPlayerId(GetTriggerPlayer())
                let st = getOrCreateState(pid)
                if idx <= st.maxPage
                    st.currentPage = idx
                    refreshGrid(pid)