package World2ScreenSync

import PrecomputedHeightMap
import SyncedCamera
import World2Screen

boolean array preCalc
real array eyeX
real array eyeY
real array eyeZ
real array lastAngleOfAttack
real array lastRotation
real array lastFieldOfView
real array cosRot
real array sinRot
real array cosAttack
real array sinAttack
real array cosAttackCosRot
real array cosAttackSinRot
real array sinAttackCosRot
real array sinAttackSinRot
real array yCenterScreenShift
real array scaleFactor

function getIndex(player whichPlayer) returns int
	return whichPlayer != null ? whichPlayer.getId() : -1

function cameraPrecalc(int pid, real newEyeX, real newEyeY, real newEyeZ, real angleOfAttack, real rotation, real fieldOfView)
	cosAttack[pid] = Cos(angleOfAttack)
	sinAttack[pid] = Sin(angleOfAttack)
	cosRot[pid] = Cos(rotation)
	sinRot[pid] = Sin(rotation)
	eyeX[pid] = newEyeX
	eyeY[pid] = newEyeY
	eyeZ[pid] = newEyeZ
	lastAngleOfAttack[pid] = angleOfAttack
	lastRotation[pid] = rotation
	lastFieldOfView[pid] = fieldOfView
	yCenterScreenShift[pid] = 0.1284 * cosAttack[pid]
	cosAttackCosRot[pid] = cosAttack[pid] * cosRot[pid]
	cosAttackSinRot[pid] = cosAttack[pid] * sinRot[pid]
	sinAttackCosRot[pid] = sinAttack[pid] * cosRot[pid]
	sinAttackSinRot[pid] = sinAttack[pid] * sinRot[pid]
	let fovSquared = fieldOfView * fieldOfView
	let fovCubed = fovSquared * fieldOfView
	scaleFactor[pid] = 0.0524 * fovCubed - 0.0283 * fovSquared + 1.061 * fieldOfView
	preCalc[pid] = true

function ensureCameraState(player whichPlayer) returns int
	let pid = getIndex(whichPlayer)
	if pid < 0
		return pid
	let newEyeX = SyncedCamera.getEyeX(whichPlayer)
	let newEyeY = SyncedCamera.getEyeY(whichPlayer)
	let newEyeZ = SyncedCamera.getEyeZ(whichPlayer)
	let newAngle = SyncedCamera.getAngleOfAttack(whichPlayer)
	let newRotation = SyncedCamera.getRotation(whichPlayer)
	let newFov = SyncedCamera.getFieldOfView(whichPlayer)
	if not preCalc[pid]
		cameraPrecalc(pid, newEyeX, newEyeY, newEyeZ, newAngle, newRotation, newFov)
		return pid
	if (newEyeX - eyeX[pid]).abs() > CAMERA_EPSILON or (newEyeY - eyeY[pid]).abs() > CAMERA_EPSILON or (newEyeZ - eyeZ[pid]).abs() > CAMERA_EPSILON
		cameraPrecalc(pid, newEyeX, newEyeY, newEyeZ, newAngle, newRotation, newFov)
		return pid
	if (newAngle - lastAngleOfAttack[pid]).abs() > CAMERA_EPSILON or (newRotation - lastRotation[pid]).abs() > CAMERA_EPSILON or (newFov - lastFieldOfView[pid]).abs() > CAMERA_EPSILON
		cameraPrecalc(pid, newEyeX, newEyeY, newEyeZ, newAngle, newRotation, newFov)
		return pid
	return pid

public function world2ScreenSynced(real x, real y, real z, player whichPlayer) returns ScreenProjection
	let pid = ensureCameraState(whichPlayer)
	if pid < 0
		return ScreenProjection(0., 0., false)
	let dx = x - eyeX[pid]
	let dy = y - eyeY[pid]
	let dz = z - eyeZ[pid]
	let xPrime = scaleFactor[pid] * (-cosAttackCosRot[pid] * dx - cosAttackSinRot[pid] * dy - sinAttack[pid] * dz)
	let xs = 0.4 + (cosRot[pid] * dy - sinRot[pid] * dx) / xPrime
	let ys = 0.42625 - yCenterScreenShift[pid] + (sinAttackCosRot[pid] * dx + sinAttackSinRot[pid] * dy - cosAttack[pid] * dz) / xPrime
	let onScreen = xPrime < 0. and xs > -0.1333 and xs < 0.9333 and ys > 0. and ys < 0.6
	return ScreenProjection(xs, ys, onScreen)

public function screen2WorldSynced(real x, real y, player whichPlayer) returns WorldIntersection
	let pid = ensureCameraState(whichPlayer)
	if pid < 0
		return WorldIntersection(0., 0., 0., false)
	let a = (x - 0.4) * scaleFactor[pid]
	let b = (0.42625 - yCenterScreenShift[pid] - y) * scaleFactor[pid]
	let denominator = safeSqrt(1. + a * a + b * b)
	if denominator <= SQRT_EPSILON
		return WorldIntersection(eyeX[pid], eyeY[pid], eyeZ[pid], false)
	let nx = 1. / denominator
	var ny = safeSqrt(1. - (1. + b * b) * nx * nx)
	var nz = safeSqrt(1. - nx * nx - ny * ny)
	if a > 0.
		ny = -ny
	if b < 0.
		nz = -nz
	let nxPrime = cosAttackCosRot[pid] * nx - sinRot[pid] * ny + sinAttackCosRot[pid] * nz
	let nyPrime = cosAttackSinRot[pid] * nx + cosRot[pid] * ny + sinAttackSinRot[pid] * nz
	let nzPrime = -sinAttack[pid] * nx + cosAttack[pid] * nz
	if nzPrime.abs() < SQRT_EPSILON
		return WorldIntersection(eyeX[pid], eyeY[pid], eyeZ[pid], false)
	let terrainGuess = getTerrainZ(eyeX[pid], eyeY[pid])
	var xGuess = eyeX[pid] + nxPrime * (eyeZ[pid] - terrainGuess) / nzPrime
	var yGuess = eyeY[pid] + nyPrime * (eyeZ[pid] - terrainGuess) / nzPrime
	var zWorld = getTerrainZ(xGuess, yGuess)
	var deltaZ = zWorld - terrainGuess
	var zGuess = zWorld
	int i = 0
	while (deltaZ > 1. or deltaZ < -1.) and i < 50
		let zWorldOld = zWorld
		let deltaZOld = deltaZ
		xGuess = eyeX[pid] + nxPrime * (eyeZ[pid] - zGuess) / nzPrime
		yGuess = eyeY[pid] + nyPrime * (eyeZ[pid] - zGuess) / nzPrime
		zWorld = getTerrainZ(xGuess, yGuess)
		deltaZ = zWorld - zGuess
		if (deltaZOld - deltaZ).abs() < SQRT_EPSILON
			return WorldIntersection(xGuess, yGuess, zWorld, false)
		zGuess = (deltaZOld * zWorld - deltaZ * zWorldOld) / (deltaZOld - deltaZ)
		i += 1
	return WorldIntersection(xGuess, yGuess, zWorld, i < 50)

public function getTriggerPlayerMouseScreenCoordinates() returns ScreenProjection
	let mouseX = BlzGetTriggerPlayerMouseX()
	let mouseY = BlzGetTriggerPlayerMouseY()
	let worldZ = getTerrainZ(mouseX, mouseY)
	return world2ScreenSynced(mouseX, mouseY, worldZ, GetTriggerPlayer())
