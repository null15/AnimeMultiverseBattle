package EntitySystem

import EntityManagement
import ClosureTimers
import HashMap

let unitPauseTimers = new HashMap<unit, CallbackSingle>()

// This tiny class attaches a Frentity to our hero.
// The entity is like a backpack where we can store extra data
// and it keeps track of the unit's position for us.
public class UnitsEntity extends UnitEntity
	boolean paused = false
	boolean basicPaused = false
	boolean absPaused = false
	CallbackSingle pauseCb = null
	CallbackSingle absPauseCb = null

	construct(unit actor)
		super(actor)

	function pauseTimed(real duration, boolean absolute)
		if absolute
			absPaused = true
			if absPauseCb != null
				destroy absPauseCb
			absPauseCb = doAfter(duration) ->
				absPauseCb = null
				absPaused = false
				this.updatePause()
		else
			basicPaused = true
			if pauseCb != null
				destroy pauseCb
			pauseCb = doAfter(duration) ->
				pauseCb = null
				basicPaused = false
				this.updatePause()
		if not paused
			actor.pause()
			paused = true

	function pauseTimed(real duration)
		pauseTimed(duration, false)

	function resume()
		basicPaused = false
		absPaused = false
		updatePause()

	function updatePause()
		if not basicPaused and not absPaused
			if paused
				actor.unpause()
				paused = false
			if pauseCb != null
				destroy pauseCb
				pauseCb = null
			if absPauseCb != null
				destroy absPauseCb
				absPauseCb = null

	function isPaused() returns boolean
		return basicPaused or absPaused

	function isAbsPaused() returns boolean
		return absPaused

	ondestroy
		if pauseCb != null
			destroy pauseCb
		if absPauseCb != null
			destroy absPauseCb

public function unit.pauseTimed(real duration, boolean absolute)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.pauseTimed(duration, absolute)
	else
		this.pause()
		if unitPauseTimers.has(this)
			let old = unitPauseTimers.get(this)
			destroy old
		let cb = doAfter(duration) ->
			this.unpause()
			unitPauseTimers.remove(this)
		unitPauseTimers.put(this, cb)

public function unit.pauseTimed(real duration)
	this.pauseTimed(duration, false)

public function unit.clearTimedPause()
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.resume()
	else
		if unitPauseTimers.has(this)
			let cb = unitPauseTimers.get(this)
			destroy cb
			unitPauseTimers.remove(this)
		if this.isPaused()
			this.unpause()

public function unit.isPausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isPaused()
	return this.isPaused()

public function unit.isAbsolutePausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isAbsPaused()
	return this.isPaused()

public class Unit
	static Unit array units
	unit actor
	UnitsEntity entity
	int uniqueID

	construct(unit actor, int uniqueID)
		this.actor = actor
		this.uniqueID = uniqueID
		this.entity = new UnitsEntity(actor)
		if units[uniqueID].actor == null
			units[uniqueID] = this
		else
			printLog(Loglevel.ERROR, "Attempted to index over another unit. Index: (" + this.uniqueID.toString() + "). Unit: ("+this.actor.getName()+")")

	static function create(player owner, int unitId, vec2 pos, int uniqueID) returns unit
		let u = createUnit(owner, unitId, pos)
		new Unit(u, uniqueID)
		return u

	static function get(int pid) returns unit
		let u = units[pid]
		return u != null ? u.actor : null

	ondestroy
		if entity != null
			destroy entity
		if this.actor != null
			this.actor.remove()
			units[uniqueID] = null

public function frentityInit()
	// Start the global entity update loop
	startEntityLoop()
