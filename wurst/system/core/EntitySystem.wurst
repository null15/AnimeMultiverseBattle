package EntitySystem

import EntityManagement
import ClosureTimers
import HashMap

let unitPauseTimers = new HashMap<unit, LinkedList<CallbackSingle>>()

/** Entity Wrapper for our Objects. With this, we're able to accurately keep track of our object data.
* For example, pause relative and pause absolute, we can accurately keep this information accurate, allowing two types of pauses to co-exist.
* In the future, we might have other data attachments we want to attach to our objects and keep them accurately represented.
*/
public class UnitsEntity extends UnitEntity
	boolean paused = false
	int basicPauseCount = 0
	int absPauseCount = 0
	LinkedList<CallbackSingle> pauseCbs = new LinkedList<CallbackSingle>()
	LinkedList<CallbackSingle> absPauseCbs = new LinkedList<CallbackSingle>()

	construct(unit actor)
		super(actor)

	function pauseTimed(real duration, boolean absolute)
		if absolute
			absPauseCount += 1
			CallbackSingle cb = null
			cb = doAfter(duration) ->
				absPauseCbs.remove(cb)
				absPauseCount -= 1
				this.updatePause()
			absPauseCbs.add(cb)
		else
			basicPauseCount += 1
			CallbackSingle cb = null
			cb = doAfter(duration) ->
				pauseCbs.remove(cb)
				basicPauseCount -= 1
				this.updatePause()
			pauseCbs.add(cb)
		if not paused
			actor.pause()
			paused = true

	function pauseTimed(real duration)
		pauseTimed(duration, false)

	function resume()
		for cb in pauseCbs
			destroy cb
		pauseCbs.clear()
		for cb in absPauseCbs
			destroy cb
		absPauseCbs.clear()
		basicPauseCount = 0
		absPauseCount = 0
		updatePause()

	function updatePause()
		if basicPauseCount == 0 and absPauseCount == 0
			if paused
				actor.unpause()
				paused = false

	function isPaused() returns boolean
		return basicPauseCount > 0 or absPauseCount > 0

	function isAbsPaused() returns boolean
		return absPauseCount > 0

	ondestroy
		for cb in pauseCbs
			destroy cb
		for cb in absPauseCbs
			destroy cb

public function unit.pauseTimed(real duration, boolean absolute)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.pauseTimed(duration, absolute)
	else
		this.pause()
		var list = unitPauseTimers.get(this)
		if list == null
			list = new LinkedList<CallbackSingle>()
			unitPauseTimers.put(this, list)
		CallbackSingle cb = null
		cb = doAfter(duration) ->
			list.remove(cb)
			if list.size() == 0
				this.unpause()
				unitPauseTimers.remove(this)
		list.add(cb)

public function unit.pauseTimed(real duration)
	this.pauseTimed(duration, false)

public function unit.clearTimedPause()
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.resume()
	else
		let list = unitPauseTimers.get(this)
		if list != null
			for cb in list
				destroy cb
			unitPauseTimers.remove(this)
		if this.isPaused()
			this.unpause()

public function unit.isPausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isPaused()
	return this.isPaused()

public function unit.isAbsolutePausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isAbsPaused()
	return this.isPaused()

public class Unit
	static Unit array units
	unit actor
	UnitsEntity entity
	int uniqueID

	construct(unit actor)
		this.actor = actor
		this.uniqueID = actor.getIndex()
		this.entity = new UnitsEntity(actor)
		if units[uniqueID] == null
			units[uniqueID] = this
		else
			printLog(Loglevel.ERROR, "Attempted to index over another unit. Index: (" + this.uniqueID.toString() + "). Unit: ("+this.actor.getName()+")")

	static function create(player owner, int unitId, vec2 pos) returns unit
		let u = createUnit(owner, unitId, pos)
		new Unit(u)
		return u

	static function get(int pid) returns unit
		let u = units[pid]
		return u != null ? u.actor : null

	ondestroy
		if entity != null
			destroy entity
		if this.actor != null
			this.actor.remove()
			units[uniqueID] = null

public function frentityInit()
	startEntityLoop()