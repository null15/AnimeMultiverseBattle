package EntitySystem

import EntityManagement
import ClosureTimers
import HashMap

let unitPauseTimers = new HashMap<unit, LinkedList<CallbackSingle>>()

/** Entity Wrapper for our Objects. With this, we're able to accurately keep track of our object data.
* For example, pause relative and pause absolute, we can accurately keep this information accurate, allowing two types of pauses to co-exist.
* In the future, we might have other data attachments we want to attach to our objects and keep them accurately represented.
*/
public class UnitsEntity extends UnitEntity
	boolean paused = false
	int basicPauseCount = 0
	int absPauseCount = 0
	LinkedList<PauseTimer> pauseCbs = new LinkedList<PauseTimer>()
	LinkedList<PauseTimer> absPauseCbs = new LinkedList<PauseTimer>()

	construct(unit actor)
		super(actor)

	function pauseTimed(real duration, boolean absolute)
		if absolute
			absPauseCount += 1
			let hndl = new PauseTimer()
			CallbackSingle cb
			cb = doAfter(duration) ->
				absPauseCbs.remove(hndl)
				absPauseCount -= 1
				hndl.finish()
				destroy hndl
				this.updatePause()
			hndl.setCallback(cb)
			absPauseCbs.add(hndl)
		else
			basicPauseCount += 1
			let hndl = new PauseTimer()
			CallbackSingle cb
			cb = doAfter(duration) ->
				pauseCbs.remove(hndl)
				basicPauseCount -= 1
				hndl.finish()
				destroy hndl
				this.updatePause()
			hndl.setCallback(cb)
			pauseCbs.add(hndl)
		if not paused
			actor.pause()
			paused = true

	function pauseTimed(real duration)
		pauseTimed(duration, false)

	function resume()
		while not pauseCbs.isEmpty()
			let hndl = pauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		while not absPauseCbs.isEmpty()
			let hndl = absPauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		basicPauseCount = 0
		absPauseCount = 0
		updatePause()

	function updatePause()
		if basicPauseCount == 0 and absPauseCount == 0
			if paused
				actor.unpause()
				paused = false

	function isPaused() returns boolean
		return basicPauseCount > 0 or absPauseCount > 0

	function isAbsPaused() returns boolean
		return absPauseCount > 0

	ondestroy
		while not pauseCbs.isEmpty()
			let hndl = pauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		while not absPauseCbs.isEmpty()
			let hndl = absPauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl

public function unit.pauseTimed(real duration, boolean absolute)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.pauseTimed(duration, absolute)
	else
		this.pause()
		var list = unitPauseTimers.get(this)
		if list == null
			list = new LinkedList<CallbackSingle>()
			unitPauseTimers.put(this, list)
		CallbackSingle cb = null
		cb = doAfter(duration) ->
			list.remove(cb)
			if list.size() == 0
				this.unpause()
				unitPauseTimers.remove(this)
		list.add(cb)

public function unit.pauseTimed(real duration)
	this.pauseTimed(duration, false)

public function unit.clearTimedPause()
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.resume()
	else
		let list = unitPauseTimers.get(this)
		if list != null
			for cb in list
				destroy cb
			unitPauseTimers.remove(this)
		if this.isPaused()
			this.unpause()

public function unit.isPausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isPaused()
	return this.isPaused()

public function unit.isAbsolutePausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isAbsPaused()
	return this.isPaused()

public class Unit
	static Unit array units
	static HashMap<int, LinkedList<unit>> unitsByType = new HashMap<int, LinkedList<unit>>()
	static unit array heroes

	unit actor
	UnitsEntity entity

	construct(unit actor)
		this.actor = actor
		this.entity = new UnitsEntity(actor)
		let idx = actor.getIndex()
		units[idx] = this
		let tid = actor.getTypeId()
		var list = unitsByType.get(tid)
		if list == null
			list = new LinkedList<unit>()
			unitsByType.put(tid, list)
		list.add(actor)
		if actor.isType(UNIT_TYPE_HERO)
			heroes[actor.getOwner().getId()] = actor

	static function create(player owner, int unitId, vec2 pos) returns unit
		let u = createUnit(owner, unitId, pos)
		return u

	static function getHero(int pid) returns unit
		return heroes[pid]

	static function getUnitsOfType(int typeID) returns LinkedList<unit>
		return unitsByType.get(typeID)

	static function fromId(int id) returns unit
		let u = units[id]
		return u != null ? u.actor : null

	ondestroy
		if entity != null
			destroy entity
		if this.actor != null
			let tid = this.actor.getTypeId()
			let list = unitsByType.get(tid)
			if list != null
				list.remove(this.actor)
				if list.isEmpty()
					unitsByType.remove(tid)
			units[this.actor.getIndex()] = null
			if this.actor.isType(UNIT_TYPE_HERO)
				let pid = this.actor.getOwner().getId()
				if heroes[pid] == this.actor
					heroes[pid] = null
			this.actor = null
		entity = null

public function unit.getId() returns int
	return this.getIndex()

class PauseTimer
	CallbackSingle cb = null
	function setCallback(CallbackSingle cb)
		this.cb = cb
	function finish()
		cb = null
	function cancel()
		if cb != null
			destroy cb
			cb = null
	ondestroy
		cancel()

public function frentityInit()
	startEntityLoop()

init
	onUnitIndex(() -> new Unit(getIndexingUnit()))
	onUnitDeindex() ->
		let u = Unit.units[getIndexingUnit().getIndex()]
		if u != null
			destroy u