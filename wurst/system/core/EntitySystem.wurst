package EntitySystem

import EntityManagement
import ClosureTimers
import HashMap
import Utility

let unitPauseTimers = new HashMap<unit, LinkedList<CallbackSingle>>()
let effectEntities = new HashMap<effect, EffectsEntity>()
let timeStopChannelExclusions = new HashMap<int, boolean>()

function channelIgnoresCasterTimeStop(int abilityId) returns boolean
	if abilityId == 0
		return false
	return timeStopChannelExclusions.has(abilityId)

public function registerTimeStopChannelExclusion(int abilityId)
	if abilityId == 0
		return
	timeStopChannelExclusions.put(abilityId, true)

public function unregisterTimeStopChannelExclusion(int abilityId)
	if abilityId == 0
		return
	if timeStopChannelExclusions.has(abilityId)
		timeStopChannelExclusions.remove(abilityId)

public function isChannelTimeStopExcluded(int abilityId) returns boolean
	return channelIgnoresCasterTimeStop(abilityId)

public class EffectsEntity
	effect actor
	vec3 position = vec3(0, 0, 0)
	real uniformScale = 1.
	vec3 matrixScale = vec3(1., 1., 1.)
	boolean useMatrixScale = false
	real timeScale = 1.
	int timeStopDepth = 0

	construct(effect actor)
		this.actor = actor
		if actor != null
			this.position = actor.getPos3()

	function getActor() returns effect
		return actor

	function setScale(real scale)
		uniformScale = scale
		useMatrixScale = false
		if actor != null
			actor.setScale(scale)

	function setScale(vec3 scale)
		matrixScale = scale
		useMatrixScale = true
		if actor != null
			actor.setScale(scale)

	function getScale() returns real
		return uniformScale

	function setPosition(vec3 pos)
		position = pos
		if actor != null
			actor.setPos(pos)

	function setPosition(vec2 pos)
		position = vec3(pos.x, pos.y, position.z)
		if actor != null
			actor.setPos(pos)

	function setHeight(real height)
		position = vec3(position.x, position.y, height)
		if actor != null
			actor.setPosition(position.x, position.y, height)

	function setTimeScale(real scale)
		timeScale = scale
		if timeStopDepth == 0 and actor != null
			actor.setTimeScale(scale)

	function getTimeScale() returns real
		return timeScale

	function applyStoredTimeScale()
		if actor != null
			actor.setTimeScale(timeScale)

	function onTimeStopStart()
		timeStopDepth += 1
		if timeStopDepth == 1 and actor != null
			actor.setTimeScale(0)

	function onTimeStopEnd()
		if timeStopDepth <= 0
			return
		timeStopDepth -= 1
		if timeStopDepth == 0
			applyStoredTimeScale()

	function clearTimeStop()
		timeStopDepth = 0
		applyStoredTimeScale()

	function reapplyState()
		if actor == null
			return
		if useMatrixScale
			actor.setScale(matrixScale)
		else
			actor.setScale(uniformScale)
		actor.setPos(position)
		if timeStopDepth == 0
			actor.setTimeScale(timeScale)

	ondestroy
		actor = null

function ensureEffectEntity(effect fx) returns EffectsEntity
	if fx == null
		return null
	var entity = effectEntities.get(fx)
	if entity == null
		entity = new EffectsEntity(fx)
		effectEntities.put(fx, entity)
	return entity

public function effect.getEntity() returns EffectsEntity
	return effectEntities.get(this)

public function effect.ensureEntity() returns EffectsEntity
	return ensureEffectEntity(this)

public function effect.releaseEntity()
	if this == null
		return
	let entity = effectEntities.get(this)
	if entity != null
		effectEntities.remove(this)
		destroy entity

public function effect.setEntityTimeScale(real scale) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setTimeScale(scale)
	return this

public function effect.getEntityTimeScale() returns real
	let entity = this.getEntity()
	return entity != null ? entity.getTimeScale() : 1.

public function effect.setEntityScale(real scale) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setScale(scale)
	return this

public function effect.setEntityScale(vec3 scale) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setScale(scale)
	return this

public function effect.setEntityPos(vec3 pos) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setPosition(pos)
	return this

public function effect.setEntityPos(vec2 pos) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setPosition(pos)
	return this

public function effect.setEntityHeight(real height) returns effect
	let entity = ensureEffectEntity(this)
	if entity != null
		entity.setHeight(height)
	return this

public function effect.destroyEntityEffect() returns effect
	if this == null
		return null
	this.releaseEntity()
	DestroyEffect(this)
	return null

public function effect.reapplyEntityState()
	let entity = this.getEntity()
	if entity != null
		entity.reapplyState()

class ChannelTracker
	UnitsEntity owner
	int abilityId = 0
	real duration = 0.
	real remaining = 0.
	boolean active = false

	construct(UnitsEntity owner)
		this.owner = owner

	function start(int abilityId, real duration)
		reset()
		if abilityId == 0
			return
		this.abilityId = abilityId
		this.duration = duration > 0. ? duration : 0.
		this.remaining = this.duration
		this.active = true

	function consume(int abilityId, real delta) returns real
		if not active or abilityId != this.abilityId
			return 0.
		if delta <= 0.
			return 0.
		let caster = owner.actor
		if caster == null or not caster.isAlive()
			reset()
			return 0.
		if owner.isTimeStopActive() and not channelIgnoresCasterTimeStop(abilityId)
			return 0.
		if remaining <= 0.
			return 0.
		let consumed = remaining < delta ? remaining : delta
		remaining -= consumed
		return consumed

	function finish(int abilityId) returns boolean
		if not active or abilityId != this.abilityId
			return false
		active = false
		remaining = 0.
		duration = 0.
		this.abilityId = 0
		return true

	function clear(int abilityId)
		if abilityId == 0 or (active and abilityId == this.abilityId)
			reset()

	function reset()
		active = false
		abilityId = 0
		duration = 0.
		remaining = 0.

	function isChanneling(int abilityId) returns boolean
		return active and abilityId == this.abilityId

	function hasChanneling() returns boolean
		return active

	function getRemaining(int abilityId) returns real
		if active and abilityId == this.abilityId
			return remaining
		return 0.

	function getDuration(int abilityId) returns real
		if abilityId == this.abilityId
			return duration
		return 0.

	ondestroy
		owner = null
/** Entity Wrapper for our Objects. With this, we're able to accurately keep track of our object data.
* For example, pause relative and pause absolute, we can accurately keep this information accurate, allowing two types of pauses to co-exist.
* In the future, we might have other data attachments we want to attach to our objects and keep them accurately represented.
*/
public class UnitsEntity extends UnitEntity
	boolean paused = false
	int basicPauseCount = 0
	int absPauseCount = 0
	LinkedList<PauseTimer> pauseCbs = new LinkedList<PauseTimer>()
	LinkedList<PauseTimer> absPauseCbs = new LinkedList<PauseTimer>()
	real timeScale = 1.
	int timeStopDepth = 0
	ChannelTracker channelTracker

	construct(unit actor)
		super(actor)
		this.channelTracker = new ChannelTracker(this)

	function pauseTimed(real duration, boolean absolute)
		if absolute
			absPauseCount += 1
			let hndl = new PauseTimer()
			CallbackSingle cb
			cb = doAfter(duration) ->
				absPauseCbs.remove(hndl)
				absPauseCount -= 1
				hndl.finish()
				destroy hndl
				this.updatePause()
			hndl.setCallback(cb)
			absPauseCbs.add(hndl)
		else
			basicPauseCount += 1
			let hndl = new PauseTimer()
			CallbackSingle cb
			cb = doAfter(duration) ->
				pauseCbs.remove(hndl)
				basicPauseCount -= 1
				hndl.finish()
				destroy hndl
				this.updatePause()
			hndl.setCallback(cb)
			pauseCbs.add(hndl)
		if not paused
			actor.pause()
			paused = true

	function pauseTimed(real duration)
		pauseTimed(duration, false)

	function resume()
		while not pauseCbs.isEmpty()
			let hndl = pauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		while not absPauseCbs.isEmpty()
			let hndl = absPauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		basicPauseCount = 0
		absPauseCount = 0
		updatePause()

	function updatePause()
		if basicPauseCount == 0 and absPauseCount == 0
			if paused
				actor.unpause()
				paused = false

	function isPaused() returns boolean
		return basicPauseCount > 0 or absPauseCount > 0

	function isAbsPaused() returns boolean
		return absPauseCount > 0

	function setTimeScale(real scale)
		timeScale = scale
		if actor != null and timeStopDepth == 0
			actor.setTimeScale(scale)

	function getTimeScale() returns real
		return timeScale

	function applyStoredTimeScale()
		if actor != null
			actor.setTimeScale(timeScale)

	function onTimeStopStart()
		timeStopDepth += 1
		if timeStopDepth == 1 and actor != null
			actor.setTimeScale(0)

	function onTimeStopEnd()
		if timeStopDepth <= 0
			return
		timeStopDepth -= 1
		if timeStopDepth == 0
			applyStoredTimeScale()

	function clearTimeStop()
		timeStopDepth = 0
		applyStoredTimeScale()

	function isTimeStopActive() returns boolean
		return timeStopDepth > 0

	function startChanneling(int abilityId, real duration)
		if channelTracker != null
			channelTracker.start(abilityId, duration)

	function consumeChanneling(int abilityId, real delta) returns real
		if channelTracker != null
			return channelTracker.consume(abilityId, delta)
		if delta <= 0.
			return 0.
		if isTimeStopActive() and not channelIgnoresCasterTimeStop(abilityId)
			return 0.
		return delta

	function finishChanneling(int abilityId)
		if channelTracker != null
			if channelTracker.finish(abilityId)
				actor.stopOrder()
		else if actor != null and actor.isAlive()
			actor.stopOrder()

	function clearChanneling(int abilityId)
		if channelTracker != null
			channelTracker.clear(abilityId)

	function clearChanneling()
		if channelTracker != null
			channelTracker.reset()

	function isChannelingAbility(int abilityId) returns boolean
		return channelTracker != null and channelTracker.isChanneling(abilityId)

	function hasChanneling() returns boolean
		return channelTracker != null and channelTracker.hasChanneling()

	function getChannelRemaining(int abilityId) returns real
		return channelTracker != null ? channelTracker.getRemaining(abilityId) : 0.

	function getChannelDuration(int abilityId) returns real
		return channelTracker != null ? channelTracker.getDuration(abilityId) : 0.

	ondestroy
		if timeStopDepth > 0
			clearTimeStop()
		if channelTracker != null
			channelTracker.reset()
			destroy channelTracker
			channelTracker = null
		while not pauseCbs.isEmpty()
			let hndl = pauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl
		while not absPauseCbs.isEmpty()
			let hndl = absPauseCbs.dequeue()
			if hndl != null
				hndl.cancel()
				destroy hndl

public function unit.pauseTimed(real duration, boolean absolute)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.pauseTimed(duration, absolute)
	else
		this.pause()
		var list = unitPauseTimers.get(this)
		if list == null
			list = new LinkedList<CallbackSingle>()
			unitPauseTimers.put(this, list)
		CallbackSingle cb = null
		cb = doAfter(duration) ->
			list.remove(cb)
			if list.size() == 0
				this.unpause()
				unitPauseTimers.remove(this)
		list.add(cb)

public function unit.pauseTimed(real duration)
	this.pauseTimed(duration, false)

public function unit.clearTimedPause()
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.resume()
	else
		let list = unitPauseTimers.get(this)
		if list != null
			for cb in list
				destroy cb
			unitPauseTimers.remove(this)
		if this.isPaused()
			this.unpause()

public function unit.isPausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isPaused()
	return this.isPaused()

public function unit.isAbsolutePausedTimed() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.isAbsPaused()
	return this.isPaused()

public function unit.startChanneling(int abilityId, real duration)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.startChanneling(abilityId, duration)

public function unit.consumeChannelTime(int abilityId, real delta) returns real
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		return u.consumeChanneling(abilityId, delta)
	if delta <= 0.
		return 0.
	return delta

public function unit.finishChanneling(int abilityId)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.finishChanneling(abilityId)
	else if this != null and this.isAlive()
		this.stopOrder()

public function unit.clearChanneling(int abilityId)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.clearChanneling(abilityId)

public function unit.clearAllChanneling()
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.clearChanneling()

public function unit.isChannelingAbility(int abilityId) returns boolean
	let u = this.getEntity() castTo UnitsEntity
	return u != null and u.isChannelingAbility(abilityId)

public function unit.isChannelingAny() returns boolean
	let u = this.getEntity() castTo UnitsEntity
	return u != null and u.hasChanneling()

public function unit.getChannelRemaining(int abilityId) returns real
	let u = this.getEntity() castTo UnitsEntity
	return u != null ? u.getChannelRemaining(abilityId) : 0.

public function unit.getChannelDuration(int abilityId) returns real
	let u = this.getEntity() castTo UnitsEntity
	return u != null ? u.getChannelDuration(abilityId) : 0.

public function unit.setEntityTimeScale(real scale)
	let u = this.getEntity() castTo UnitsEntity
	if u != null
		u.setTimeScale(scale)
	else
		SetUnitTimeScale(this, scale)

public function unit.getEntityTimeScale() returns real
	let u = this.getEntity() castTo UnitsEntity
	return u != null ? u.getTimeScale() : 1.

public class Unit
	static Unit array units
	static HashMap<int, LinkedList<unit>> unitsByType = new HashMap<int, LinkedList<unit>>()
	static unit array heroes
	unit actor
	UnitsEntity entity

	construct(unit actor)
		this.actor = actor
		this.entity = new UnitsEntity(actor)
		let idx = actor.getIndex()
		units[idx] = this
		let tid = actor.getTypeId()
		var list = unitsByType.get(tid)
		if list == null
			list = new LinkedList<unit>()
			unitsByType.put(tid, list)
		list.add(actor)
		if actor.isType(UNIT_TYPE_HERO)
			heroes[actor.getOwner().getId()] = actor

	static function create(player owner, int unitId, vec2 pos) returns unit
		let u = createUnit(owner, unitId, pos)
		return u

	static function getHero(int pid) returns unit
		return heroes[pid]

	static function getUnitsOfType(int typeID) returns LinkedList<unit>
		return unitsByType.get(typeID)

	static function fromId(int id) returns unit
		let u = units[id]
		return u != null ? u.actor : null

	ondestroy
		if entity != null
			destroy entity
		if this.actor != null
			let tid = this.actor.getTypeId()
			let list = unitsByType.get(tid)
			if list != null
				list.remove(this.actor)
				if list.isEmpty()
					unitsByType.remove(tid)
			units[this.actor.getIndex()] = null
			if this.actor.isType(UNIT_TYPE_HERO)
				let pid = this.actor.getOwner().getId()
				if heroes[pid] == this.actor
					heroes[pid] = null
			this.actor = null
		entity = null

public function unit.getId() returns int
	return this.getIndex()

class PauseTimer
	CallbackSingle cb = null
	function setCallback(CallbackSingle cb)
		this.cb = cb
	function finish()
		cb = null
	function cancel()
		if cb != null
			destroy cb
			cb = null
	ondestroy
		cancel()

public function frentityInit()
	startEntityLoop()

init
	onUnitIndex(() -> new Unit(getIndexingUnit()))
	onUnitDeindex() ->
		let u = Unit.units[getIndexingUnit().getIndex()]
		if u != null
			destroy u