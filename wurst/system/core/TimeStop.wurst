package TimeStop

import HashMap
import ClosureTimers
import TimeStopOverlay
import EntitySystem
import EntityManagement

let timeStopStates = new HashMap<unit, TimeStopState>()
let playerStopCounts = new HashMap<player, int>()

function addPlayerControl(player p)
	if p == null
		return
	let current = playerStopCounts.has(p) ? playerStopCounts.get(p) : 0
	if current == 0
		p.disableControl()
	playerStopCounts.put(p, current + 1)

function releasePlayerControl(player p)
	if p == null
		return
	if not playerStopCounts.has(p)
		return
	let current = playerStopCounts.get(p)
	if current <= 1
		playerStopCounts.remove(p)
		p.enableControl()
	else
		playerStopCounts.put(p, current - 1)

class TimeStopTimer
	CallbackSingle cb = null

	function setCallback(CallbackSingle cb)
		this.cb = cb

	function finish()
		cb = null

	function cancel()
		if cb != null
			destroy cb
			cb = null

	ondestroy
		cancel()

class TimeStopState
	unit tracked
	unit target
	LinkedList<TimeStopTimer> timers
	int count = 0
	angle originalPropWindow = angle(0)
	real originalTurnRate = 0.
	real originalTimeScale = 1.
	boolean stored = false
	boolean destroying = false
	player owner = null

	construct(unit target)
		this.tracked = target
		this.target = target
		this.timers = new LinkedList<TimeStopTimer>()

	function start()
		if count == 0
			activate()
		count += 1

	function activate()
		if stored
			return
		if target != null
			originalPropWindow = target.getPropWindow()
			originalTurnRate = target.getField(UNIT_RF_TURN_RATE)
			originalTimeScale = target.getEntityTimeScale()
			let entity = target.getEntity() castTo UnitsEntity
			target
			..setPropWindow(angle(0))
			..setField(UNIT_RF_TURN_RATE, 0)
			..disableAttack(true, false)
			if entity != null
				entity.onTimeStopStart()
			else
				target.setTimeScale(0)
			owner = target.getOwner()
		else
			owner = null
		addPlayerControl(owner)
		stored = true

	function decrease()
		if count == 0
			return
		count -= 1
		if count == 0
			deactivate()

	function deactivate()
		if stored
			if target != null
				let entity = target.getEntity() castTo UnitsEntity
				target
				..setPropWindow(angle(originalPropWindow.radians()))
				..setField(UNIT_RF_TURN_RATE, originalTurnRate)
				..disableAttack(false, false)
				if entity != null
					entity.onTimeStopEnd()
				else
					target.setTimeScale(originalTimeScale)
			if owner != null
				releasePlayerControl(owner)
			owner = null
			stored = false
		cleanupIfIdle()

	function addTimer(TimeStopTimer time)
		timers.add(time)

	function removeTimer(TimeStopTimer time)
		timers.remove(time)
		cleanupIfIdle()

	function clear()
		while not timers.isEmpty()
			let time = timers.dequeue()
			if time != null
				time.cancel()
				destroy time
		count = 0
		deactivate()

	function onUnitRemoved()
		target = null
		clear()

	function isActive() returns boolean
		return count > 0

	function cleanupIfIdle()
		if destroying
			return
		if count == 0 and timers.isEmpty() and not stored
			destroying = true
			if tracked != null and timeStopStates.has(tracked)
				timeStopStates.remove(tracked)
			destroy this

	ondestroy
		while not timers.isEmpty()
			let time = timers.dequeue()
			if time != null
				time.cancel()
				destroy time
		destroy timers
		target = null
		tracked = null
		owner = null

function ensureState(unit target) returns TimeStopState
	if target == null
		return null
	var state = timeStopStates.get(target)
	if state == null
		state = new TimeStopState(target)
		timeStopStates.put(target, state)
	return state

public function unit.startTimeStop()
	let state = ensureState(this)
	if state != null
		state.start()

public function unit.stopTimeStop()
	let state = timeStopStates.get(this)
	if state != null
		state.decrease()

public function unit.timeStopTimed(real duration)
	let state = ensureState(this)
	if state == null
		return
	state.start()
	if duration <= 0
		state.decrease()
		return
	let time = new TimeStopTimer()
	state.addTimer(time)
	CallbackSingle cb
	cb = doAfter(duration) ->
		state.decrease()
		state.removeTimer(time)
		time.finish()
		destroy time
	time.setCallback(cb)

public function unit.clearTimeStop()
	let state = timeStopStates.get(this)
	if state != null
		state.clear()

public function unit.isTimeStopped() returns boolean
	let state = timeStopStates.get(this)
	return state != null and state.isActive()

function onUnitRemoved()
	let u = getIndexingUnit()
	if u != null and timeStopStates.has(u)
		let state = timeStopStates.get(u)
		if state != null
			state.onUnitRemoved()

init
	onUnitDeindex(() -> onUnitRemoved())