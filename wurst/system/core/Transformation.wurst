package Transformation

import ClosureTimers
import HashMap
import Entity
import objectIDs

// Needs more work. Look into Tinkers Engineering. https://www.hiveworkshop.com/threads/engineering-upgrade.302459/
// Why more work? because when all spells maxed, its fine. Maybe be able to set ability back to original level later when evo over.
// Or try tinker engineering way.

public class Transformation
    static HashMap<unit, Transformation> active = new HashMap<unit, Transformation>
    unit actor
    int originalSkin
    IterableMap<int, int> swaps
    unit bar
    CallbackCounted cbPeriodicBar
    // optional callback invoked when the transformation ends
    Callback onFinish
    bool finished

    construct(unit actor, int newSkin, IterableMap<int, int> swaps, real duration, Callback onFinish)
        if active.has(actor)
            active.get(actor).finish()
        this.actor = actor
        this.swaps = swaps
        this.originalSkin = BlzGetUnitSkin(this.actor)
        this.onFinish = onFinish
        this.finished = false

        // Unit Stuff
        active.put(actor, this)
        
        this.actor
        ..addAbility(ALL_MIGHT_BEARFORM)
        ..removeAbility(ALL_MIGHT_BEARFORM)
        ..addAnimationProperties("alternate", true)
        swaps.forEach() (integer baseAbil, integer evoAbil) ->
            this.actor.disableAbility(baseAbil, true, true)
            this.actor.addAbility(evoAbil)
        BlzSetUnitSkin(this.actor, newSkin)

        // Progress Bar
        this.bar = createUnit(this.actor.getOwner(), PROGRESS_BAR_DUMMY, this.actor.getEntity() != null ? this.actor.getEntity().getPos().add(0, 0, 400) : this.actor.getPos3Real().add(0, 0, 400), angle(270))
            ..setVertexColor(this.actor.getOwner().getColor().toColor())
            ..setPosReal(this.actor.getEntity() != null ? this.actor.getEntity().getPos().add(0, 0, 300) : this.actor.getPos3Real().add(0, 0, 300))
            ..setAnimation(100)

        // Timer Stuff
        this.cbPeriodicBar = doPeriodicallyTimed(0.032, duration) (CallbackCounted cb) ->
            let progressLeft = 1.0 - cb.progress()
            let value = (100.0 * progressLeft).toInt()
            this.bar
                ..setPosReal(this.actor.getEntity() != null ? this.actor.getEntity().getPos().add(0, 0, 300) : this.actor.getPos3Real().add(0, 0, 300))
                ..setAnimation(value)
            if cb.isLast()
                finish()
    
    static function start(unit actor, int newSkin, IterableMap<int, int> swaps, real duration) returns Transformation
        return Transformation.start(actor, newSkin, swaps, duration, null)

    static function start(unit actor, int newSkin, IterableMap<int, int> swaps, real duration, Callback onFinish) returns Transformation
        if actor == null or not actor.isAlive()
            return null
        return new Transformation(actor, newSkin, swaps, duration, onFinish)

    function cancel()
        finish()

    function finish()
        if this.finished
            return 
        this.finished = true
        if this.cbPeriodicBar != null
            destroy this.cbPeriodicBar
            this.cbPeriodicBar = null
        if this.bar != null
            this.bar.setAnimation(0)
            this.bar.remove()
            this.bar = null
        this.actor
        ..addAbility(ALL_MIGHT_BEARFORM)
        ..removeAbility(ALL_MIGHT_BEARFORM)
        this.swaps.forEach() (integer baseAbil, integer transAbil) ->
            this.actor.disableAbility(baseAbil, false, false)
            this.actor.removeAbility(transAbil)
        BlzSetUnitSkin(this.actor, this.originalSkin)
        active.remove(this.actor)
        if this.onFinish != null
            this.onFinish.call()
            this.onFinish = null
        destroy this

    ondestroy
        if this.cbPeriodicBar != null
            destroy this.cbPeriodicBar
            this.cbPeriodicBar = null
        if this.bar != null
            this.bar.remove()
            this.bar = null
        if active.has(this.actor)
            active.remove(this.actor)
        destroy this.swaps