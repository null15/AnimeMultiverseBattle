package BindingProjectileSystem

import HashMap
import Missiles
import EntityManagement

constant HashMap<unit, effect> anchorVisuals = new HashMap<unit, effect>()

public interface BindingImpactHandler
	function apply(BindingProjectile projectile, unit victim) returns bool

public interface BindingDurationProvider
	function compute(unit caster, unit target) returns real

public interface BindingTargetCondition
	function allows(BindingProjectile projectile, unit target) returns bool

public interface BindingMissileSetup
	function apply(BindingProjectile projectile, Missiles missile)

public interface BindingFinishHandler
	function onFinish(BindingProjectile projectile)

public class AnchorVisualSetup
	string modelPath
	real scale
	real heightOffset
	angle pitch
	angle roll

	construct(string modelPath, real scale, real heightOffset, angle pitch, angle roll)
		this.modelPath = modelPath
		this.scale = scale
		this.heightOffset = heightOffset
		this.pitch = pitch
		this.roll = roll

public class BindingProjectileConfig
	string projectileModelPath
	real projectileScale = 1.
	real projectileSpeed
	real collision
	real heightOffset = 0.
	real forwardOffset = 0.
	real fallbackDistance = 600.
	boolean hideFxOnRemove = true
	boolean collideZ = false
	boolean requireHeroTarget = false
	boolean requireEnemyTarget = false
	BindingDurationProvider durationProvider
	BindingImpactHandler impactHandler
	BindingTargetCondition targetCondition
	BindingMissileSetup missileSetup
	BindingFinishHandler finishHandler

	construct(string projectileModelPath, real collision, real speed)
		this.projectileModelPath = projectileModelPath
		this.collision = collision
		this.projectileSpeed = speed

public class BindingProjectile
	BindingProjectileConfig config
	Missiles missile
	unit ownerUnit
	unit initialCaster
	unit initialTarget
	player ownerPlayer
	player initialOwner
	angle travelYaw = angle(0.)
	real bindDuration = 0.
	boolean completed = false
	boolean deflected = false

	construct(unit caster, unit target, BindingProjectileConfig config)
		this.config = config
		this.initialCaster = caster
		this.ownerUnit = caster
		this.initialTarget = target
		this.ownerPlayer = caster != null ? caster.getOwner() : null
		this.initialOwner = this.ownerPlayer
		this.bindDuration = this.bindDuration(caster, target)
		this.launchMissile(caster, target)

	function getConfig() returns BindingProjectileConfig
		return this.config

	function getBindDuration() returns real
		return this.bindDuration

	function getOwnerUnit() returns unit
		return this.ownerUnit

	function getMissile() returns Missiles
		return this.missile

	function getOwner() returns player
		if this.ownerPlayer != null
			return this.ownerPlayer
		if this.initialCaster != null
			return this.initialCaster.getOwner()
		return null

	function getFacingYaw(unit victim) returns angle
		if this.ownerUnit != null and victim != null
			return this.ownerUnit.getPos().angleTo(victim.getPos())
		if this.missile != null and victim != null
			return this.missile.getPos().toVec2().angleTo(victim.getPos())
		return this.travelYaw

	function getTravelYaw() returns angle
		return this.travelYaw

	function bindDuration(unit caster, unit target) returns real
		if this.config != null and this.config.durationProvider != null
			return this.config.durationProvider.compute(caster, target)
		return 0.

	function launchMissile(unit caster, unit target)
		if caster == null or this.config == null
			this.completed = true
			return
		let config = this.config
		let casterEntity = caster.getEntity()
		let originBase = casterEntity != null ? casterEntity.getPos() : caster.getPos3Real()
		let launchBase = originBase.add(0, 0, config.heightOffset)
		let facing = this.getLaunchFacing(caster)
		let launchPos = launchBase + facing.toVec(config.forwardOffset)
		let targetPos2d = this.getTargetLocation(caster, target, launchPos, facing)
		this.travelYaw = launchPos.toVec2().angleTo(targetPos2d)
		let impactPos = this.getImpactPosition(caster, target, launchPos, facing)
		this.missile = new Missiles(launchPos, impactPos)
		this.missile.owner = this.ownerPlayer
		this.missile.source = caster
		this.missile.target = target
		this.missile.collision = config.collision
		this.missile.collideZ = config.collideZ
		if config.projectileModelPath.length() > 0
			this.missile.setModel(config.projectileModelPath)
		this.missile.setScale(config.projectileScale)
		this.missile.setHideFxOnRemove(config.hideFxOnRemove)
		this.missile.setSpeed(config.projectileSpeed)
		this.missile.onHit(u -> this.onHit(u))
		this.missile.onFinish(() -> this.onFinish())
		this.missile.onRemove(() -> this.onRemove())
		this.missile.onPeriod(() -> this.onPeriod())
		if config.missileSetup != null
			config.missileSetup.apply(this, this.missile)
		this.missile.launch()

	function getLaunchFacing(unit caster) returns angle
		if caster == null
			return angle(0.)
		let target = this.initialTarget
		if target != null
			let facing = caster.getPos().angleTo(target.getPos())
			caster.setFacing(facing)
			return facing
		return caster.getFacingAngle()

	function getTargetLocation(unit _caster, unit target, vec3 launchPos, angle facing) returns vec2
		if target != null
			return target.getPos()
		return launchPos.toVec2() + facing.toVec(1.)

	function getImpactPosition(unit _caster, unit target, vec3 launchPos, angle facing) returns vec3
		if target != null
			return target.getPos3Real().add(0, 0, this.config.heightOffset)
		return launchPos + facing.toVec(this.config.fallbackDistance)

	function onHit(unit u) returns bool
		if this.completed
			return false
		if not this.isTargetEligible(u)
			return false
		if not this.deflected and this.initialTarget != null and u != this.initialTarget
			if this.missile != null
				this.missile.flush(u)
			return false
		this.completed = true
		return this.handleHit(u)

	function handleHit(unit victim) returns bool
		if this.config != null and this.config.impactHandler != null
			return this.config.impactHandler.apply(this, victim)
		return false

	function isTargetEligible(unit u) returns bool
		if u == null or not u.isAlive()
			return false
		if this.config.requireHeroTarget and not u.isType(UNIT_TYPE_HERO)
			return false
		if this.config.requireEnemyTarget
			let owner = this.getOwner()
			if owner == null or not u.isEnemyOf(owner)
				return false
		if this.shouldIgnoreUnit(u)
			return false
		return this.isCustomTargetAllowed(u)

	function shouldIgnoreUnit(unit u) returns bool
		return this.ownerUnit != null and u == this.ownerUnit

	function isCustomTargetAllowed(unit u) returns bool
		if this.config != null and this.config.targetCondition != null
			return this.config.targetCondition.allows(this, u)
		return true

	function onPeriod() returns bool
		if this.missile == null
			return false
		if this.tryAutoBindInitialTarget()
			return true
		if not this.deflected and this.initialTarget != null and not this.initialTarget.isAlive()
			this.clearInitialTarget()
		if this.missile.owner != this.ownerPlayer
			this.ownerPlayer = this.missile.owner
			if this.deflected
				if this.missile != null
					this.missile.flush()
			else if this.initialOwner != null and this.ownerPlayer != this.initialOwner
				this.markDeflected()
			if this.missile.source != null and this.missile.source.getOwner() == this.ownerPlayer
				this.ownerUnit = this.missile.source
			else
				this.ownerUnit = null
		else if this.missile.source != null and this.missile.source != this.ownerUnit and this.missile.source.getOwner() == this.ownerPlayer
			this.ownerUnit = this.missile.source
		if not this.deflected and this.missile.target == null and this.initialTarget != null
			this.clearInitialTarget()
		if this.missile.target != null
			this.travelYaw = this.missile.getPos().toVec2().angleTo(this.missile.target.getPos())
		return false

	function tryAutoBindInitialTarget() returns bool
		if this.completed or this.deflected
			return false
		let target = this.initialTarget
		if target == null or not target.isAlive()
			return false
		if this.missile == null
			return false
		let missilePos = this.missile.getPos().toVec2()
		let maxDistance = this.config.collision + target.getCollisionSize()
		if missilePos.distanceTo(target.getPos()) > maxDistance
			return false
		return this.onHit(target)

	function markDeflected()
		if this.deflected
			return
		this.deflected = true
		if not this.clearInitialTarget() and this.missile != null
			this.missile.flush()

	function clearInitialTarget() returns bool
		if this.initialTarget == null
			return false
		this.initialTarget = null
		if this.missile != null
			this.missile.flush()
		return true

	function onFinish() returns bool
		this.completed = true
		if this.config != null and this.config.finishHandler != null
			this.config.finishHandler.onFinish(this)
		return false

	function onRemove()
		this.missile = null
		destroy this

	function applyAnchorVisual(unit anchor, unit target, AnchorVisualSetup setup) returns effect
		if anchor == null or setup == null
			return null
		let fallback = this.getFacingYaw(target)
		let yaw = this.computeAnchorYaw(anchor, target, fallback)
		return setAnchorVisual(anchor, setup.modelPath, setup.heightOffset, setup.scale, yaw, setup.pitch, setup.roll)

	function computeAnchorYaw(unit anchor, unit target, angle fallback) returns angle
		if this.ownerUnit != null and target != null
			return this.ownerUnit.getPos().angleTo(target.getPos())
		if anchor != null and target != null
			return anchor.getPos().angleTo(target.getPos())
		if anchor != null
			return anchor.getFacingAngle()
		return fallback

	function destroyAnchorVisual(unit anchor)
		clearAnchorVisual(anchor)

	ondestroy
		this.ownerUnit = null
		this.initialCaster = null
		this.initialTarget = null
		this.ownerPlayer = null
		this.initialOwner = null
		this.config = null

public function launchBindingProjectile(unit caster, unit target, BindingProjectileConfig config) returns BindingProjectile
	if caster == null
		return null
	return new BindingProjectile(caster, target, config)

public function setAnchorVisual(unit anchor, string modelPath, real heightOffset, real scale, angle yaw, angle pitch, angle roll) returns effect
	clearAnchorVisual(anchor)
	if anchor == null or modelPath.length() == 0
		return null
	let pos = anchor.getPos3Real().add(0, 0, heightOffset)
	let fx = addEffect(modelPath, pos)
	if fx != null
		fx..setScale(scale)..setOrientation(yaw, pitch, roll)
		anchorVisuals.put(anchor, fx)
	return fx

public function clearAnchorVisual(unit anchor)
	if anchor == null
		return
	if anchorVisuals.has(anchor)
		let fx = anchorVisuals.get(anchor)
		if fx != null
			fx..setPos(vec2(-99999, -99999))..destr()
		anchorVisuals.remove(anchor)

function onAnchorRemoved()
	let u = getIndexingUnit()
	if u != null
		clearAnchorVisual(u)

init
	onUnitDeindex(() -> onAnchorRemoved())
