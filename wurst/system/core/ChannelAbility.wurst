package ChannelAbility

import HashMap
import HashSet
import ClosureTimers
import EntitySystem
import EffectsSystem
import EntityManagement
import TimeStop
import SoundSystem

/**
* Tracks an individual effect or effect entity and mirrors Time Stop state.
* Keeps the effect frozen when any watcher is frozen and resumes afterwards.
* Optionally destroys the effect when the tracker is released or cleaned up.
*/
public class EffectTimeStopTracker
	EffectsEntity sfx
	effect actor
	HashSet<unit> watchers
	boolean destroyOnFinish
	boolean timeStopped

	/**
	* Builds a tracker for the provided effect entity.
	* sfx: Effect wrapper to monitor for Time Stop synchronization.
	* destroyOnFinish: True if the effect should be destroyed on release.
	*/
	construct(EffectsEntity sfx, boolean destroyOnFinish)
		this.sfx = sfx
		this.actor = sfx != null ? sfx.getActor() : null
		this.destroyOnFinish = destroyOnFinish
		this.watchers = new HashSet<unit>
		this.timeStopped = false

	/**
	* Resolves the current effect entity or null if the backing actor died.
	* Refreshes the cached actor reference so later updates remain valid.
	* Returns the latest effect entity instance being tracked.
	*/
	function resolveEffectEntity() returns EffectsEntity
		if this.actor == null
			this.sfx = null
			return null
		let entity = this.actor.getEntity()
		if entity == null
			this.sfx = null
			this.actor = null
			return null
		this.sfx = entity
		return entity

	/**
	* Registers a unit whose Time Stop state controls this effect.
	* watcher: Unit that should freeze or resume the effect when frozen.
	* Ignores null references to stay leak free.
	*/
	function addWatcher(unit watcher)
		if watcher == null
			return
		this.watchers.add(watcher)

	/**
	* Registers multiple watcher units at once.
	* units: Collection of units that should influence the effect freeze.
	* Skips null collections and relies on addWatcher for validation.
	*/
	function addWatchers(HashSet<unit> units)
		if units == null
			return
		for u in units
			this.addWatcher(u)

	/**
	* Evaluates if any watcher is currently frozen by Time Stop.
	* Returns true when the effect must be paused for synchronization.
	* Returns false when the effect can run normally.
	*/
	function shouldFreeze() returns boolean
		if this.watchers == null or this.watchers.isEmpty()
			return false
		for watcher in this.watchers
			if watcher != null and watcher.isTimeStopped()
				return true
		return false

	/**
	* Starts freezing the effect actor when Time Stop is active.
	* Ensures the internal actor is valid before issuing the freeze call.
	*/
	function startTimeStop()
		if this.resolveEffectEntity() == null
			return
		if this.actor != null
			this.actor.startTimeStop()

	/**
	* Resumes playback for the tracked effect actor.
	* No-op if the actor reference was already cleaned.
	*/
	function stopTimeStop()
		if this.resolveEffectEntity() == null
			return
		if this.actor != null
			this.actor.stopTimeStop()

	/**
	* Applies the initial freeze state immediately after registration.
	* Helps persistent effects start paused if the watchers are frozen.
	*/
	function applyInitialState()
		if this.resolveEffectEntity() == null
			this.timeStopped = false
			return
		if this.shouldFreeze()
			this.timeStopped = true
			this.startTimeStop()
		else if this.timeStopped
			this.timeStopped = false
			this.stopTimeStop()

	/**
	* Polls watcher state and toggles the effect freeze accordingly.
	* Called during spell ticks to remain synchronized with Time Stop.
	*/
	function updateState()
		if this.resolveEffectEntity() == null
			this.timeStopped = false
			return
		let freeze = this.shouldFreeze()
		if freeze
			if not this.timeStopped
				this.timeStopped = true
				this.startTimeStop()
		else if this.timeStopped
			this.timeStopped = false
			this.stopTimeStop()

	/**
	* Releases references and optionally destroys the effect entity.
	* Called when the owning spell is cleaned or finishes safely.
	*/
	function release()
		let entity = this.resolveEffectEntity()
		if this.destroyOnFinish and entity != null
			destroyEffectEntity(entity)
		this.sfx = null
		this.actor = null
		if this.watchers != null
			destroy this.watchers
		this.watchers = null
		this.timeStopped = false

	/**
	* Returns the currently tracked effect entity reference.
	* Can return null when the effect was destroyed.
	*/
	function getEffect() returns EffectsEntity
		return this.resolveEffectEntity()

	ondestroy
		this.sfx = null
		this.actor = null
		if this.watchers != null
			destroy this.watchers
		this.watchers = null

// ------------------------------------------------------------ //

/*
* Tracks channel ability IDs that should ignore Time Stop interruptions.
* Prevents duplicated exclusion registrations when multiple spells coexist.
*/
let channelExclusionCounts = new HashMap<int, int>()

/**
* Registers an ability ID as Time Stop immune for channel orders.
* abilityId: Raw ability ID that should stay valid while channeling.
* Safe-guards against zero or duplicate registrations.
*/
function addChannelExclusion(int abilityId)
	if abilityId == 0
		return
	var count = 0
	if channelExclusionCounts.has(abilityId)
		count = channelExclusionCounts.get(abilityId)
	count += 1
	channelExclusionCounts.put(abilityId, count)
	if count == 1
		registerTimeStopChannelExclusion(abilityId)

/**
* Removes a previously registered channel exclusion.
* abilityId: Raw ability ID that should resume normal Time Stop rules.
* Automatically unregisters when the reference count reaches zero.
*/
function removeChannelExclusion(int abilityId)
	if abilityId == 0
		return
	if not channelExclusionCounts.has(abilityId)
		return
	var count = channelExclusionCounts.get(abilityId)
	count -= 1
	if count <= 0
		channelExclusionCounts.remove(abilityId)
		unregisterTimeStopChannelExclusion(abilityId)
	else
		channelExclusionCounts.put(abilityId, count)

/**
* Base spell that keeps every tracked handle safe while Time Stop is active.
* The class owns every resource it touches (RAII) and releases them inside finishSpell/ondestroy, so extending classes only need to register what they spawn.
* Use this when you want the Time Stop features without the channel specific helpers provided by ChannelSpell.
*/
class TimeStopAwareSpell
	unit caster
	int abilityId
	real tickPeriod
	CallbackPeriodic periodic
	LinkedList<EffectTimeStopTracker> trackedEffects
	HashSet<unit> trackedUnits
	HashSet<unit> timeScaleSources
	real casterTimeScaleBeforeOverride
	boolean casterTimeScaleOverridden
	ChannelSoundPlayback channelSound
	boolean cleanedUp

	/**
	* Creates a new spell instance and starts tracking its caster.
	* caster: Unit that owns the spell.
	* abilityId: Raw ability id supplied by the object editor.
	* tickPeriod: Seconds between each periodic call, set to 0 for manual ticking.
	*/
	construct(unit caster, int abilityId, real tickPeriod)
		this.caster = caster
		this.abilityId = abilityId
		this.tickPeriod = tickPeriod
		this.trackedEffects = new LinkedList<EffectTimeStopTracker>()
		this.trackedUnits = new HashSet<unit>
		this.timeScaleSources = new HashSet<unit>
		this.casterTimeScaleBeforeOverride = 1.
		this.casterTimeScaleOverridden = false
		this.cleanedUp = false
		if caster != null
			this.registerUnit(caster)

	/**
	* Returns the unit that created the spell instance or null if it has been removed.
	*/
	function getCaster() returns unit
		return this.caster

	/**
	* Returns the raw ability id that was passed into the constructor.
	*/
	function getAbilityId() returns int
		return this.abilityId

	/**
	* Returns the tick period that drives the periodic callbacks.
	*/
	function getTickPeriod() returns real
		return this.tickPeriod

	/**
	* Starts the periodic loop when a positive tick period is available.
	* The instance drives its own cleanup, so you never need to destroy the timer yourself.
	*/
	function startTicking()
		if this.periodic != null
			return
		if this.tickPeriod <= 0.
			return
		let inst = this
		this.periodic = doPeriodically(this.tickPeriod) (CallbackPeriodic c) ->
			inst.tick()

	/**
	* Stops the periodic loop and releases the closure timer when one exists.
	*/
	function stopTicking()
		if this.periodic != null
			destroy this.periodic
			this.periodic = null

	/**
	* Runs before each periodic tick. Override to prepare state or skip work.
	*/
	function onBeforeTick()
		// override

	/**
	* Runs every periodic tick. Override to implement the spell behaviour.
	*/
	function onTick()
		// override

	/**
	* Internal driver that wraps onBeforeTick and onTick with safety checks and Time Stop updates.
	*/
	function tick()
		if this.cleanedUp
			return
		this.onBeforeTick()
		if this.cleanedUp
			return
		this.updateTrackedEffects()
		this.updateCasterTimeScaleOverride()
		if this.cleanedUp
			return
		this.onTick()

	/**
	* Updates freeze state on all registered effect trackers so they stay in sync with Time Stop.
	*/
	function updateTrackedEffects()
		if this.trackedEffects == null or this.trackedEffects.isEmpty()
			return
		for tracker in this.trackedEffects
			if tracker != null
				tracker.updateState()

	/**
	* Registers a unit so the spell can pause when it becomes frozen and clears the reference during cleanup.
	*/
	function registerUnit(unit watcher)
		if watcher == null
			return
		if this.trackedUnits != null
			this.trackedUnits.add(watcher)

	/**
	* Registers every unit contained in the supplied set.
	*/
	function registerUnits(HashSet<unit> units)
		if units == null
			return
		for u in units
			this.registerUnit(u)

	/**
	* Returns true when any registered unit is currently frozen by Time Stop.
	*/
	function anyTrackedUnitTimeStopped() returns boolean
		if this.trackedUnits == null or this.trackedUnits.isEmpty()
			return false
		for u in this.trackedUnits
			if u != null and u.isTimeStopped()
				return true
		return false

	/**
	* Registers an effect so it pauses and resumes with the spell and gets cleaned up automatically.
	* sfx: Effect entity created by the spell.
	* destroyOnFinish: True when the effect should be destroyed during cleanup, false for persistent effects.
	* Returns the tracker which can watch extra units for freeze decisions.
	*/
	function registerEffect(EffectsEntity sfx, boolean destroyOnFinish) returns EffectTimeStopTracker
		if sfx == null
			return null
		let tracker = new EffectTimeStopTracker(sfx, destroyOnFinish)
		this.trackedEffects.add(tracker)
		tracker.applyInitialState()
		return tracker

	/**
	* Convenience overload that destroys the effect during cleanup.
	*/
	function registerEffect(EffectsEntity sfx) returns EffectTimeStopTracker
		return this.registerEffect(sfx, true)

	/**
	* Registers an effect and also observes one extra unit.
	* watcher: Unit whose Time Stop state will pause or resume the effect. A watcher is simply a unit the tracker listens to.
	*/
	function registerEffectWithUnit(EffectsEntity sfx, unit watcher) returns EffectTimeStopTracker
		let tracker = this.registerEffect(sfx, true)
		if tracker != null
			tracker.addWatcher(watcher)
		return tracker

	/**
	* Registers an effect and observes each unit in the supplied set.
	* watchers: Every watcher contributes its Time Stop state when deciding if the effect should run.
	*/
	function registerEffectWithUnits(EffectsEntity sfx, HashSet<unit> watchers) returns EffectTimeStopTracker
		let tracker = this.registerEffect(sfx, true)
		if tracker != null
			tracker.addWatchers(watchers)
		return tracker

	/**
	* Registers an effect that should stay alive after the spell and observes one watcher unit.
	*/
	function registerPersistentEffectWithUnit(EffectsEntity sfx, unit watcher) returns EffectTimeStopTracker
		let tracker = this.registerEffect(sfx, false)
		if tracker != null
			tracker.addWatcher(watcher)
		return tracker

	/**
	* Registers a persistent effect and observes every watcher in the supplied set.
	*/
	function registerPersistentEffectWithUnits(EffectsEntity sfx, HashSet<unit> watchers) returns EffectTimeStopTracker
		let tracker = this.registerEffect(sfx, false)
		if tracker != null
			tracker.addWatchers(watchers)
		return tracker

	/**
	* Stores the looping sound so it can pause, resume, and stop automatically.
	*/
	function setChannelSound(ChannelSoundPlayback snd)
		if this.channelSound != null and this.channelSound != snd
			this.channelSound.stop()
		this.channelSound = snd

	/**
	* Stops the stored sound and clears the reference.
	*/
	function stopChannelSound()
		if this.channelSound != null
			this.channelSound.stop()
		this.channelSound = null

	/**
	* Registers an extra unit whose frozen state should also freeze the caster's animation.
	*/
	function registerTimeScaleSource(unit source)
		if source == null
			return
		if this.timeScaleSources != null
			this.timeScaleSources.add(source)

	/**
	* Returns true when any registered time scale source is frozen while the caster remains active.
	*/
	function shouldOverrideCasterTimeScale() returns boolean
		let casterUnit = this.caster
		if casterUnit == null
			return false
		if not casterUnit.isAlive()
			return false
		if casterUnit.isTimeStopped()
			return false
		if this.timeScaleSources == null or this.timeScaleSources.isEmpty()
			return false
		for unit source in this.timeScaleSources
			if source != null and source.isTimeStopped()
				return true
		return false

	/**
	* Freezes the caster's animation and records the previous time scale so it can be restored.
	*/
	function startCasterTimeScaleOverride()
		if this.casterTimeScaleOverridden
			return
		let casterUnit = this.caster
		if casterUnit == null
			return
		this.casterTimeScaleBeforeOverride = casterUnit.getEntityTimeScale()
		casterUnit.setEntityTimeScale(0.)
		this.casterTimeScaleOverridden = true

	/**
	* Restores the caster's previous time scale when the override is no longer needed.
	*/
	function stopCasterTimeScaleOverride()
		if not this.casterTimeScaleOverridden
			return
		let casterUnit = this.caster
		if casterUnit != null
			casterUnit.setEntityTimeScale(this.casterTimeScaleBeforeOverride)
		this.casterTimeScaleOverridden = false

	/**
	* Evaluates the override each tick so the caster freezes only when needed.
	*/
	function updateCasterTimeScaleOverride()
		if this.shouldOverrideCasterTimeScale()
			this.startCasterTimeScaleOverride()
		else
			this.stopCasterTimeScaleOverride()

	/**
	* Releases every registered effect tracker. Called automatically from finishSpell.
	*/
	function cleanupEffects()
		if this.trackedEffects == null or this.trackedEffects.isEmpty()
			return
		for tracker in this.trackedEffects
			if tracker != null
				tracker.release()
		this.trackedEffects.clear()

	/**
	* Runs after cleanupEffects. Override to release additional data.
	*/
	function onCleanup()
		// override

	/**
	* Completes the spell lifecycle. Stops ticking, sounds, overrides, clears trackers, and destroys the instance.
	*/
	function finishSpell()
		if this.cleanedUp
			return
		this.cleanedUp = true
		this.stopTicking()
		this.stopCasterTimeScaleOverride()
		this.stopChannelSound()
		this.cleanupEffects()
		this.onCleanup()
		if this.trackedUnits != null
			this.trackedUnits.clear()
		if this.timeScaleSources != null
			this.timeScaleSources.clear()
		destroy this

	ondestroy
		this.caster = null
		if this.periodic != null
			destroy this.periodic
		this.periodic = null
		if this.trackedEffects != null
			for tracker in this.trackedEffects
				if tracker != null
					destroy tracker
			this.trackedEffects = null
		if this.trackedUnits != null
			destroy this.trackedUnits
		this.trackedUnits = null
		if this.timeScaleSources != null
			destroy this.timeScaleSources
		this.timeScaleSources = null
		this.channelSound = null

// ------------------------------------------------------------ //

/**
* Recommended base for every ability that should cooperate with Time Stop.
* The spell owns its channel state, targets, sounds, and other resources (RAII) and releases them as soon as finishChannel or finishSpell is called.
*
* This system is our Core when creating abilities that should work perfectly with Time Stop related mechanic.
*
* ## Example 1 - Looping beam that ticks every 0.25 seconds for three seconds.
*	class BeamSpell extends ChannelSpell
*		construct(unit caster)
*			super(caster, 'A000', 0.25)
*		function start()
*			this.beginChannel(3.)
*		override function onChannelTick()
*			// damage, move effects, etc.
*
* ## Example 2 - Instant strike that only needs one tick and forwards to helper functions.
*	class InstantStrike extends ChannelSpell
*		construct(unit caster)
*			super(caster, 'A001', 0.03)
*		function start()
*			this.beginChannel(0.)
*		override function onChannelTick()
*			this.runPrimaryHit()
*		function runPrimaryHit()
*			this.runFollowUp()
*		function runFollowUp()
*			// whatever you want here, etc
*
* ## Example 3 - Protected channel that survives global exclusions.
*	class SafeChannel extends ChannelSpell
*		construct(unit caster)
*			super(caster, 'A002', 0.5)
*		function start()
*			this.enableChannelExclusion()
*			this.beginChannel(5.)
*		override function onChannelTick()
*			// perform work while the channel exclusion is active
*/
public class ChannelSpell extends TimeStopAwareSpell
	HashSet<unit> targets
	boolean channelStarted
	boolean channelActive
	real channelDuration
	boolean hasChannelDuration
	boolean allowTicksDuringTimeStop
	boolean skipTick
	boolean channelExclusionActive

	/**
	* Creates a channel spell with its caster, ability id, and tick period.
	* caster: Unit that owns the channel.
	* abilityId: Raw ability id tied to the object data entry.
	* tickPeriod: Seconds between onChannelTick calls. Use 0 for manual ticking.
	*/
	construct(unit caster, int abilityId, real tickPeriod)
		super(caster, abilityId, tickPeriod)
		this.targets = new HashSet<unit>
		this.channelStarted = false
		this.channelActive = false
		this.channelDuration = 0.
		this.hasChannelDuration = false
		this.allowTicksDuringTimeStop = false
		this.skipTick = false
		this.channelExclusionActive = false

	/**
	* Adds a unit to the target set so it is tracked, paused, and released automatically.
	*/
	function addTarget(unit target)
		if target == null
			return
		this.targets.add(target)
		this.registerUnit(target)

	/**
	* Controls whether onChannelTick keeps running while the caster is frozen by Time Stop.
	* allow: True lets the tick fire during a freeze, false skips the tick until time resumes.
	*/
	function setAllowTicksDuringTimeStop(boolean allow)
		this.allowTicksDuringTimeStop = allow

	/**
	* Marks this spell as excluded from global channel cancellation.
	* Use this when Time Stop should freeze the caster without auto ordering them to stop.
	*/
	function enableChannelExclusion()
		if this.channelExclusionActive
			return
		addChannelExclusion(this.getAbilityId())
		this.channelExclusionActive = true

	/**
	* Removes the exclusion flag once the spell no longer needs protection.
	*/
	function disableChannelExclusion()
		if not this.channelExclusionActive
			return
		removeChannelExclusion(this.getAbilityId())
		this.channelExclusionActive = false

	/**
	* Returns true while the channel is running and false after finishChannel completes.
	*/
	function isChannelActive() returns boolean
		return this.channelActive

	/**
	* Returns true after beginChannel has been called at least once.
	*/
	function isChannelStarted() returns boolean
		return this.channelStarted

	/**
	* Convenience helper that forwards to finishChannel.
	* orderCaster: True issues the finish order to the caster, false clears silently.
	*/
	function stop(boolean orderCaster)
		this.finishChannel(orderCaster)

	/**
	* Registers every unit inside the provided set by calling addTarget on each.
	*/
	function addTargets(HashSet<unit> units)
		if units == null
			return
		for u in units
			this.addTarget(u)

	/**
	* Starts the channel and optionally provides a countdown timer.
	* duration: Seconds to keep channeling. Use 0 to run until finishChannel is called.
	*/
	function beginChannel(real duration)
		if this.channelStarted
			return
		this.channelStarted = true
		this.channelActive = true
		this.channelDuration = duration
		this.hasChannelDuration = duration > 0.
		let casterUnit = this.getCaster()
		if casterUnit != null
			casterUnit.startChanneling(this.getAbilityId(), duration)

	/**
	* Override to pause the countdown without cancelling the channel.
	* Return true when the spell should stay active but skip tick work for this frame.
	*/
	function shouldPauseChannel() returns boolean
		return false

	/**
	* Runs before each tick to make sure the caster is alive, still channeling, and allowed to act.
	* Handles caster death, lost orders, natural completion, manual pauses, and Time Stop freezes.
	*/
	override function onBeforeTick()
		if not this.channelActive
			this.skipTick = true
			return
		this.skipTick = false
		let casterUnit = this.getCaster()
		if casterUnit == null or not casterUnit.isAlive()
			this.handleCasterInvalid()
			this.skipTick = true
			return
		if not this.channelStarted
			this.skipTick = true
			return
		if not casterUnit.isChannelingAbility(this.getAbilityId())
			this.handleChannelLost()
			this.skipTick = true
			return
		if this.hasChannelDuration
			if this.shouldPauseChannel()
				this.skipTick = true
				return
			let consumed = casterUnit.consumeChannelTime(this.getAbilityId(), this.getTickPeriod())
			if consumed <= 0.
				if not this.allowTicksDuringTimeStop
					this.skipTick = true
					return
			if casterUnit.getChannelRemaining(this.getAbilityId()) <= 0.
				this.handleChannelCompleted()
				this.skipTick = true
				return
		else
			if this.shouldPauseChannel()
				this.skipTick = true
				return
			if not this.allowTicksDuringTimeStop and casterUnit.isTimeStopped()
				this.skipTick = true
				return
	/**
	* Calls onChannelTick unless onBeforeTick marked the tick to be skipped.
	*/
	override function onTick()
		if this.skipTick
			return
		this.onChannelTick()

	/**
	* Override to implement the actual channel behaviour for each tick.
	*/
	function onChannelTick()
		// override

	/**
	* Called when the caster dies or is no longer valid. Default behaviour finishes the channel without sending the finish order.
	*/
	function handleCasterInvalid()
		if this.channelActive
			this.finishChannel(false)

	/**
	* Called when the caster lost the channel order. Default behaviour finishes the channel without sending the finish order.
	*/
	function handleChannelLost()
		if this.channelActive
			this.finishChannel(false)

	/**
	* Called when the configured duration reaches zero. Default behaviour finishes the channel and issues the finish order.
	*/
	function handleChannelCompleted()
		if this.channelActive
			this.finishChannel(true)

	/**
	* Runs whenever finishChannel is called. Return true to run finishSpell right away, false to keep the instance alive for extra cleanup.
	*/
	function onChannelFinish(boolean orderCaster) returns boolean
		return orderCaster

	/**
	* Main teardown entry point used by every handler.
	* orderCaster: True issues the finish order, false clears the channel instantly.
	*/
	function finishChannel(boolean orderCaster)
		if not this.channelActive
			return
		this.channelActive = false
		let casterUnit = this.getCaster()
		if casterUnit != null
			if orderCaster
				casterUnit.finishChanneling(this.getAbilityId())
			else
				casterUnit.clearChanneling(this.getAbilityId())
		this.disableChannelExclusion()
		let shouldFinalize = this.onChannelFinish(orderCaster)
		if shouldFinalize
			this.finishSpell()

	/**
	* Clears tracked targets. Override to clean custom data before the instance is destroyed.
	*/
	override function onCleanup()
		if this.targets != null
			this.targets.clear()

	ondestroy
		this.disableChannelExclusion()
		if this.targets != null
			destroy this.targets
		this.targets = null