package SoundSystem

import ClosureTimers
import HashMap
import Time
import EntityManagement
import EntitySystem
import TimeStop

@configurable constant DEFAULT_SOUND_STOPS_ON_LEAVE_RANGE = true
@configurable constant DEFAULT_SOUND_FADE_IN_RATE = 10
@configurable constant DEFAULT_SOUND_FADE_OUT_RATE = 10
@configurable constant DEFAULT_SOUND_EAX_SETTINGS = "CombatSoundsEAX"
@configurable constant DEFAULT_SOUND_VOLUME = 127
@configurable constant DEFAULT_SOUND_PITCH = 1.
@configurable constant DEFAULT_SOUND_DURATION = 10000
@configurable constant DEFAULT_SOUND_CHANNEL = 5
@configurable constant DEFAULT_SOUND_MIN_DISTANCE = 600.
@configurable constant DEFAULT_SOUND_MAX_DISTANCE = 8000.
@configurable constant DEFAULT_SOUND_DISTANCE_CUTOFF = 1500.

constant real SOUND_PLAYBACK_TIMER_DURATION = 3600.
constant real CHANNEL_SOUND_UPDATE_PERIOD = 0.03125

function managedSoundTimerNoOp()
	// Intentionally empty â€“ used to keep playback timers alive.
	return

public class SoundProfile
	string filePath
	string defaultLabel = ""
	boolean looping = false
	boolean is3D = false
	boolean stopWhenOutOfRange = DEFAULT_SOUND_STOPS_ON_LEAVE_RANGE
	int fadeInRate = DEFAULT_SOUND_FADE_IN_RATE
	int fadeOutRate = DEFAULT_SOUND_FADE_OUT_RATE
	string eaxSetting = DEFAULT_SOUND_EAX_SETTINGS
	int baseDuration = DEFAULT_SOUND_DURATION
	int baseChannel = DEFAULT_SOUND_CHANNEL
	int baseVolume = DEFAULT_SOUND_VOLUME
	real basePitch = DEFAULT_SOUND_PITCH
	real minDistance = DEFAULT_SOUND_MIN_DISTANCE
	real maxDistance = DEFAULT_SOUND_MAX_DISTANCE
	real distanceCutoff = DEFAULT_SOUND_DISTANCE_CUTOFF

	private function initProfile(string filePath, boolean looping, boolean is3D, string label)
		this.filePath = filePath
		this.looping = looping
		this.is3D = is3D
		this.setLabel(label)

	construct(string filePath)
		this.initProfile(filePath, false, false, filePath)

	construct(string filePath, boolean looping)
		this.initProfile(filePath, looping, false, filePath)

	construct(string filePath, boolean looping, boolean is3D)
		this.initProfile(filePath, looping, is3D, filePath)

	construct(string filePath, string label)
		this.initProfile(filePath, false, false, label)

	construct(string filePath, string label, boolean looping)
		this.initProfile(filePath, looping, false, label)

	construct(string filePath, string label, boolean looping, boolean is3D)
		this.initProfile(filePath, looping, is3D, label)

	construct(SoundProfile other)
		this.initProfile(other.filePath, other.looping, other.is3D, other.defaultLabel)
		this.stopWhenOutOfRange = other.stopWhenOutOfRange
		this.fadeInRate = other.fadeInRate
		this.fadeOutRate = other.fadeOutRate
		this.eaxSetting = other.eaxSetting
		this.baseDuration = other.baseDuration
		this.baseChannel = other.baseChannel
		this.baseVolume = other.baseVolume
		this.basePitch = other.basePitch
		this.minDistance = other.minDistance
		this.maxDistance = other.maxDistance
		this.distanceCutoff = other.distanceCutoff

	function setLooping(boolean looping) returns SoundProfile
		this.looping = looping
		return this

	function set3D(boolean is3D) returns SoundProfile
		this.is3D = is3D
		return this

	function setLabel(string label) returns SoundProfile
		if label == null or label.length() == 0
			this.defaultLabel = ""
		else
			this.defaultLabel = label
		return this

	function setStopWhenOutOfRange(boolean value) returns SoundProfile
		this.stopWhenOutOfRange = value
		return this

	function setFadeRates(int fadeInRate, int fadeOutRate) returns SoundProfile
		this.fadeInRate = fadeInRate
		this.fadeOutRate = fadeOutRate
		return this

	function setEaxSetting(string eaxSetting) returns SoundProfile
		this.eaxSetting = eaxSetting
		return this

	function setDuration(int duration) returns SoundProfile
		this.baseDuration = duration
		return this

	function setChannel(int channel) returns SoundProfile
		this.baseChannel = channel
		return this

	function setVolume(int volume) returns SoundProfile
		this.baseVolume = volume
		return this

	function setPitch(real pitch) returns SoundProfile
		this.basePitch = pitch
		return this

	function setDistances(real minDist, real maxDist, real cutoff) returns SoundProfile
		this.minDistance = minDist
		this.maxDistance = maxDist
		this.distanceCutoff = cutoff
		return this

	function getFilePath() returns string
		return this.filePath

	function getLabel() returns string
		return this.resolveLabel("")

	function getDuration() returns int
		return this.baseDuration

	function getChannel() returns int
		return this.baseChannel

	function getVolume() returns int
		return this.baseVolume

	function getPitch() returns real
		return this.basePitch

	function getMinDistance() returns real
		return this.minDistance

	function getMaxDistance() returns real
		return this.maxDistance

	function getDistanceCutoff() returns real
		return this.distanceCutoff

	function getFadeInRate() returns int
		return this.fadeInRate

	function getFadeOutRate() returns int
		return this.fadeOutRate

	function getEaxSetting() returns string
		return this.eaxSetting

	function stopsWhenOutOfRange() returns boolean
		return this.stopWhenOutOfRange

	function uses3D() returns boolean
		return this.is3D

	function isLooping() returns boolean
		return this.looping

	function resolveLabel(string label) returns string
		if label != null and label.length() > 0
			return label
		if this.defaultLabel != null and this.defaultLabel.length() > 0
			return this.defaultLabel
		return this.filePath != null ? this.filePath : ""

public class ManagedSound
	SoundProfile profile
	string label
	sound hndl
	player targetPlayer = null
	unit attachedUnit = null
	vec3 position = ZERO3
	boolean hasPosition = false
	boolean is3D = false
	boolean playing = false
	timer playbackTimer = null
	boolean playbackTimerRunning = false
	real playbackElapsedMsBase = 0.
	int startOffsetMs = 0
	int channel
	int configuredDuration
	int volume
	real pitch
	real minDistance
	real maxDistance
	real distanceCutoff

	construct(string label, SoundProfile profile)
		if profile != null
			this.profile = new SoundProfile(profile)
		let source = this.profile != null ? this.profile : profile
		let resolvedLabel = source != null ? source.resolveLabel(label) : (label != null ? label : "")
		this.label = resolvedLabel
		this.is3D = source != null ? source.uses3D() : false
		this.channel = source != null ? source.getChannel() : DEFAULT_SOUND_CHANNEL
		this.configuredDuration = source != null ? source.getDuration() : DEFAULT_SOUND_DURATION
		this.volume = source != null ? source.getVolume() : DEFAULT_SOUND_VOLUME
		this.pitch = source != null ? source.getPitch() : DEFAULT_SOUND_PITCH
		this.minDistance = source != null ? source.getMinDistance() : DEFAULT_SOUND_MIN_DISTANCE
		this.maxDistance = source != null ? source.getMaxDistance() : DEFAULT_SOUND_MAX_DISTANCE
		this.distanceCutoff = source != null ? source.getDistanceCutoff() : DEFAULT_SOUND_DISTANCE_CUTOFF
		if source != null
			this.hndl = CreateSound(source.getFilePath(), source.isLooping(), source.uses3D(), source.stopsWhenOutOfRange(), source.getFadeInRate(), source.getFadeOutRate(), source.getEaxSetting())
		if this.hndl != null
			this.hndl.setChannel(this.channel)
			this.hndl.setVolume(this.volume)
			this.hndl.setPitch(this.pitch)
			this.hndl.setDuration(this.configuredDuration)
			if this.is3D
				SetSoundDistances(this.hndl, this.minDistance, this.maxDistance)
				SetSoundDistanceCutoff(this.hndl, this.distanceCutoff)
		registerSound(this)

	private function ensurePlaybackTimer() returns timer
		if this.playbackTimer == null
			this.playbackTimer = CreateTimer()
		return this.playbackTimer

	private function restartPlaybackTimer()
		let time = this.ensurePlaybackTimer()
		time.pause()
		time.start(SOUND_PLAYBACK_TIMER_DURATION, function managedSoundTimerNoOp)
		this.playbackTimerRunning = true

	private function stopPlaybackTimer()
		if this.playbackTimer != null and this.playbackTimerRunning
			this.playbackElapsedMsBase += this.playbackTimer.getElapsed() * 1000.
			this.playbackTimer.pause()
			this.playbackTimerRunning = false

	private function resetPlaybackTracking(real offsetMs)
		this.playbackElapsedMsBase = offsetMs
		this.restartPlaybackTimer()

	private function getAccumulatedPlaybackMs() returns real
		var total = this.playbackElapsedMsBase
		if this.playbackTimer != null and this.playbackTimerRunning
			total += this.playbackTimer.getElapsed() * 1000.
		return total

	private function refreshPlaybackState()
		if this.playing and this.hndl != null and not this.hndl.isPlaying()
			this.stopPlaybackTimer()
			this.playing = false

	function getProfile() returns SoundProfile
		return this.profile

	function getSound() returns sound
		return this.hndl

	function getLabel() returns string
		return this.label

	function setLabel(string newLabel) returns ManagedSound
		if this.label == newLabel
			return this
		removeSoundFromLabelIndex(this, this.label)
		this.label = newLabel
		addSoundToLabelIndex(this, newLabel)
		return this

	function getPlayer() returns player
		return this.targetPlayer

	function setPlayer(player whichPlayer) returns ManagedSound
		this.targetPlayer = whichPlayer
		return this

	function getAttachedUnit() returns unit
		return this.attachedUnit

	function attachToUnit(unit target) returns ManagedSound
		this.attachedUnit = target
		if this.hndl != null and target != null
			AttachSoundToUnit(this.hndl, target)
		return this

	function clearAttachment() returns ManagedSound
		this.attachedUnit = null
		return this

	function getPosition() returns vec3
		return this.position

	function setPosition(vec3 pos) returns ManagedSound
		this.position = pos
		this.hasPosition = true
		if this.hndl != null and this.is3D
			SetSoundPosition(this.hndl, pos.x, pos.y, pos.z)
		return this

	function setPosition(vec2 pos) returns ManagedSound
		return this.setPosition(vec3(pos.x, pos.y, this.position.z))

	function setHeight(real height) returns ManagedSound
		return this.setPosition(vec3(this.position.x, this.position.y, height))

	function setStartOffsetMs(int offset) returns ManagedSound
		this.startOffsetMs = offset
		return this

	function setStartOffsetMilliseconds(int offset) returns ManagedSound
		return this.setStartOffsetMs(offset)

	function setChannel(int channel) returns ManagedSound
		this.channel = channel
		if this.hndl != null
			this.hndl.setChannel(channel)
		return this

	function getChannel() returns int
		return this.channel

	function setVolume(int volume) returns ManagedSound
		this.volume = volume
		if this.hndl != null
			this.hndl.setVolume(volume)
		return this

	function getVolume() returns int
		return this.volume

	function setPitch(real pitch) returns ManagedSound
		this.pitch = pitch
		if this.hndl != null
			this.hndl.setPitch(pitch)
		return this

	function getPitch() returns real
		return this.pitch

	function setDuration(int duration) returns ManagedSound
		this.configuredDuration = duration
		if this.hndl != null
			this.hndl.setDuration(duration)
		return this

	function getConfiguredDuration() returns int
		return this.configuredDuration

	function getConfiguredDurationMs() returns int
		return this.configuredDuration

	function getNativeDurationMs() returns int
		if this.hndl != null
			return this.hndl.getDuration()
		return this.configuredDuration

	function setDistances(real minDist, real maxDist, real cutoff) returns ManagedSound
		this.minDistance = minDist
		this.maxDistance = maxDist
		this.distanceCutoff = cutoff
		if this.hndl != null and this.is3D
			SetSoundDistances(this.hndl, minDist, maxDist)
			SetSoundDistanceCutoff(this.hndl, cutoff)
		return this

	function setConeAngles(real inside, real outside, int outsideVolume) returns ManagedSound
		if this.hndl != null
			SetSoundConeAngles(this.hndl, inside, outside, outsideVolume)
		return this

	function setConeOrientation(vec3 direction) returns ManagedSound
		if this.hndl != null
			SetSoundConeOrientation(this.hndl, direction.x, direction.y, direction.z)
		return this

	function setVelocity(vec3 velocity) returns ManagedSound
		if this.hndl != null
			SetSoundVelocity(this.hndl, velocity.x, velocity.y, velocity.z)
		return this

	function play() returns ManagedSound
		if this.hndl == null
			return this
		if this.playing
			return this
		if this.startOffsetMs < 0
			this.startOffsetMs = 0
		this.resetPlaybackTracking(this.startOffsetMs.toReal())
		this.playing = true
		if this.attachedUnit != null
			AttachSoundToUnit(this.hndl, this.attachedUnit)
		else if this.is3D and this.hasPosition
			SetSoundPosition(this.hndl, this.position.x, this.position.y, this.position.z)
		if this.targetPlayer != null
			if GetLocalPlayer() == this.targetPlayer
				StartSound(this.hndl)
				if this.startOffsetMs != 0
					SetSoundPlayPosition(this.hndl, this.startOffsetMs)
		else
			StartSound(this.hndl)
			if this.startOffsetMs != 0
				SetSoundPlayPosition(this.hndl, this.startOffsetMs)
		this.startOffsetMs = 0
		return this

	function playAt(vec3 pos) returns ManagedSound
		this.setPosition(pos)
		return this.play()

	function playForPlayer(player whichPlayer) returns ManagedSound
		this.setPlayer(whichPlayer)
		return this.play()

	function playFromMilliseconds(int offset) returns ManagedSound
		this.setStartOffsetMs(offset)
		return this.play()

	function restartFromMilliseconds(int offset) returns ManagedSound
		this.stop(false, false)
		this.resetPlayedTime()
		this.setStartOffsetMs(offset)
		return this.play()

	function stop(boolean killWhenDone, boolean fadeOut) returns ManagedSound
		this.refreshPlaybackState()
		if this.hndl == null
			return this
		if this.playing
			this.playing = false
		this.stopPlaybackTimer()
		this.hndl.stop(killWhenDone, fadeOut)
		return this

	function stop() returns ManagedSound
		return this.stop(false, false)

	function pause() returns ManagedSound
		if this.hndl == null
			return this
		this.refreshPlaybackState()
		if not this.playing
			return this
		let offset = this.getPlayedMilliseconds()
		this.stop(false, false)
		this.startOffsetMs = offset
		return this

	function resume() returns ManagedSound
		if this.hndl == null
			return this
		if this.playing
			return this
		let offset = this.getPlayedMilliseconds()
		if offset <= 0
			return this.play()
		return this.playFromMilliseconds(offset)

	function fadeOut() returns ManagedSound
		return this.stop(false, true)

	function kill() returns ManagedSound
		return this.stop(true, false)

	function resetPlayedTime() returns ManagedSound
		this.playbackElapsedMsBase = 0.
		if this.playing
			this.restartPlaybackTimer()
		else if this.playbackTimer != null
			this.playbackTimer.pause()
			this.playbackTimerRunning = false
		this.startOffsetMs = 0
		return this

	function getPlayedSeconds() returns real
		this.refreshPlaybackState()
		return this.getAccumulatedPlaybackMs() / 1000.

	function getPlayedMilliseconds() returns int
		return R2I(this.getAccumulatedPlaybackMs())

	function getPlayedDuration() returns duration
		return this.getPlayedSeconds().seconds()

	function isPlaying() returns boolean
		this.refreshPlaybackState()
		return this.playing

	function is3DSound() returns boolean
		return this.is3D

	function getMinDistance() returns real
		return this.minDistance

	function getMaxDistance() returns real
		return this.maxDistance

	function getDistanceCutoff() returns real
		return this.distanceCutoff

	function setDistancesFromProfile(SoundProfile source) returns ManagedSound
		if source == null
			return this
		return this.setDistances(source.getMinDistance(), source.getMaxDistance(), source.getDistanceCutoff())

	ondestroy
		this.refreshPlaybackState()
		this.stopPlaybackTimer()
		if this.playbackTimer != null
			this.playbackTimer.pause()
			this.playbackTimer.destr()
			this.playbackTimer = null
		this.playbackTimerRunning = false
		this.playbackElapsedMsBase = 0.
		unregisterSound(this)
		if this.hndl != null
			this.hndl.stop(true, false)
			this.hndl = null
		this.attachedUnit = null
		this.targetPlayer = null

public class SoundPlayback
	LinkedList<ManagedSound> instances

	construct()
		this.instances = new LinkedList<ManagedSound>()

	construct(LinkedList<ManagedSound> existing)
		this.instances = new LinkedList<ManagedSound>()
		this.addAll(existing)

	function add(ManagedSound snd) returns SoundPlayback
		if snd != null
			this.instances.add(snd)
		return this

	function addAll(LinkedList<ManagedSound> sounds) returns SoundPlayback
		if sounds == null
			return this
		for snd in sounds
			this.add(snd)
		return this

	function isEmpty() returns boolean
		return this.instances.isEmpty()

	function size() returns int
		return this.instances.size()

	function getFirst() returns ManagedSound
		if this.instances.isEmpty()
			return null
		return this.instances.getFirst()

	function getInstances() returns LinkedList<ManagedSound>
		let copy = new LinkedList<ManagedSound>()
		for snd in this.instances
			copy.add(snd)
		return copy

	function getForPlayer(player whichPlayer) returns ManagedSound
		if whichPlayer == null
			return null
		for snd in this.instances
			if snd != null and snd.getPlayer() == whichPlayer
				return snd
		return null

	function getPlayback() returns ManagedSound
		let local = this.getForPlayer(localPlayer)
		if local != null
			return local
		return this.getFirst()

	function getPlayedMilliseconds() returns int
		let snd = this.getPlayback()
		if snd != null
			return snd.getPlayedMilliseconds()
		return 0

	function getConfiguredDurationMs() returns int
		let snd = this.getPlayback()
		if snd != null
			return snd.getConfiguredDuration()
		let first = this.getFirst()
		return first != null ? first.getConfiguredDuration() : 0

	function getNativeDurationMs() returns int
		let snd = this.getPlayback()
		if snd != null
			return snd.getNativeDurationMs()
		let first = this.getFirst()
		return first != null ? first.getNativeDurationMs() : 0

	function stopAll(boolean killWhenDone, boolean fadeOut) returns SoundPlayback
		for snd in this.instances
			if snd != null
				snd.stop(killWhenDone, fadeOut)
		return this

	function stopAll() returns SoundPlayback
		return this.stopAll(false, false)

	function fadeOutAll() returns SoundPlayback
		return this.stopAll(false, true)

	function killAll() returns SoundPlayback
		return this.stopAll(true, false)

	function pauseAll() returns SoundPlayback
		for snd in this.instances
			if snd != null
				snd.pause()
		return this

	function resumeAll() returns SoundPlayback
		for snd in this.instances
			if snd != null
				snd.resume()
		return this

public class ChannelSoundPlayback
	unit caster
	int abilityId
	SoundPlayback playback
	CallbackPeriodic time
	boolean paused = false
	boolean destroying = false

	construct(unit caster, int abilityId, SoundPlayback playback)
		this.caster = caster
		this.abilityId = abilityId
		this.playback = playback
		if caster != null and caster.isTimeStopped() and playback != null and not playback.isEmpty()
			playback.pauseAll()
			this.paused = true
		this.time = doPeriodically(CHANNEL_SOUND_UPDATE_PERIOD) (CallbackPeriodic c) ->
			this.update()

	function getPlayback() returns SoundPlayback
		return this.playback

	function stop()
		this.terminate(true)

	function update()
		if this.destroying
			return
		let casterUnit = this.caster
		if casterUnit == null or not casterUnit.isAlive()
			this.terminate(true)
			return
		if this.abilityId != 0 and not casterUnit.isChannelingAbility(this.abilityId)
			this.terminate(true)
			return
		if this.playback == null or this.playback.isEmpty()
			return
		let shouldPause = casterUnit.isTimeStopped()
		if shouldPause
			if not this.paused
				this.paused = true
				this.playback.pauseAll()
		else if this.paused
			this.paused = false
			this.playback.resumeAll()

	function terminate(boolean stopPlayback)
		if this.destroying
			return
		this.destroying = true
		if this.time != null
			destroy this.time
			this.time = null
		if stopPlayback and this.playback != null
			this.playback.stopAll()
		this.playback = null
		this.caster = null
		destroy this

	ondestroy
		if this.time != null
			destroy this.time
			this.time = null
		this.playback = null
		this.caster = null

let trackedSounds = new LinkedList<ManagedSound>()
let soundsByLabel = new HashMap<string, LinkedList<ManagedSound>>()

function addSoundToLabelIndex(ManagedSound snd, string label)
	if snd == null
		return
	if label == null or label.length() == 0
		return
	var list = soundsByLabel.get(label)
	if list == null
		list = new LinkedList<ManagedSound>()
		soundsByLabel.put(label, list)
	list.add(snd)

function removeSoundFromLabelIndex(ManagedSound snd, string label)
	if snd == null
		return
	if label == null or label.length() == 0
		return
	let list = soundsByLabel.get(label)
	if list == null
		return
	list.remove(snd)
	if list.isEmpty()
		soundsByLabel.remove(label)

function registerSound(ManagedSound snd)
	if snd == null
		return
	trackedSounds.add(snd)
	addSoundToLabelIndex(snd, snd.getLabel())

function unregisterSound(ManagedSound snd)
	if snd == null
		return
	trackedSounds.remove(snd)
	removeSoundFromLabelIndex(snd, snd.getLabel())

public function getAllSounds() returns LinkedList<ManagedSound>
	let result = new LinkedList<ManagedSound>()
	for snd in trackedSounds
		result.add(snd)
	return result

public function getSoundsWithLabel(string label) returns LinkedList<ManagedSound>
	let result = new LinkedList<ManagedSound>()
	if label == null or label.length() == 0
		return result
	let list = soundsByLabel.get(label)
	if list == null
		return result
	for snd in list
		result.add(snd)
	return result

public function getPlaybackForLabel(string label) returns SoundPlayback
	let playback = new SoundPlayback()
	if label == null or label.length() == 0
		return playback
	let list = soundsByLabel.get(label)
	if list == null
		return playback
	for snd in list
		playback.add(snd)
	return playback

public function stopAllSounds(boolean killWhenDone, boolean fadeOut)
	for snd in trackedSounds
		snd.stop(killWhenDone, fadeOut)

public function stopAllSounds()
	stopAllSounds(false, false)

public function killAllSounds()
	stopAllSounds(true, false)

public function stopSoundsWithLabel(string label, boolean killWhenDone, boolean fadeOut)
	if label == null or label.length() == 0
		return
	let list = soundsByLabel.get(label)
	if list == null
		return
	for snd in list
		snd.stop(killWhenDone, fadeOut)

public function stopSoundsWithLabel(string label)
	stopSoundsWithLabel(label, false, false)

public function killSoundsWithLabel(string label)
	stopSoundsWithLabel(label, true, false)

public function destroySoundsWithLabel(string label)
	if label == null or label.length() == 0
		return
	let list = soundsByLabel.get(label)
	if list == null
		return
	let snapshot = new LinkedList<ManagedSound>()
	for snd in list
		snapshot.add(snd)
	for snd in snapshot
		destroy snd

public function SoundProfile.playChannel(unit caster, int abilityId, vec3 pos, real range) returns ChannelSoundPlayback
	return this.playChannel(caster, abilityId, pos, range, this.getLabel())

public function SoundProfile.playChannel(unit caster, int abilityId, vec3 pos, real range, string label) returns ChannelSoundPlayback
	let playback = playSound(this, pos, range, label)
	if caster != null
		for snd in playback.getInstances()
			if snd != null
				snd.attachToUnit(caster)
	return new ChannelSoundPlayback(caster, abilityId, playback)

public function SoundProfile.playChannelForUnit(unit caster, int abilityId, real range) returns ChannelSoundPlayback
	return this.playChannelForUnit(caster, abilityId, range, this.getLabel())

public function SoundProfile.playChannelForUnit(unit caster, int abilityId, real range, string label) returns ChannelSoundPlayback
	var origin = vec3(0, 0, 0)
	if caster != null
		let casterEntity = caster.getEntity()
		origin = casterEntity != null ? casterEntity.getPos() : caster.getPos3Real()
	return this.playChannel(caster, abilityId, origin, range, label)

public function SoundProfile.createInstance() returns ManagedSound
	return new ManagedSound(this.getLabel(), this)

public function SoundProfile.createInstance(string label) returns ManagedSound
	return new ManagedSound(label, this)

public function SoundProfile.createInstanceForPlayer(player whichPlayer) returns ManagedSound
	let snd = this.createInstance()
	snd.setPlayer(whichPlayer)
	return snd

public function SoundProfile.createInstanceForPlayer(string label, player whichPlayer) returns ManagedSound
	let snd = new ManagedSound(label, this)
	snd.setPlayer(whichPlayer)
	return snd

public function SoundProfile.playAt(vec3 pos, real range) returns SoundPlayback
	return playSound(this, pos, range, this.getLabel())

public function SoundProfile.playAt(vec3 pos, real range, string label) returns SoundPlayback
	return playSound(this, pos, range, label)

public function SoundProfile.playFrom(vec3 pos, real range, int startOffsetMs) returns SoundPlayback
	return playSoundFrom(this, pos, range, this.getLabel(), startOffsetMs)

public function SoundProfile.playFrom(vec3 pos, real range, string label, int startOffsetMs) returns SoundPlayback
	return playSoundFrom(this, pos, range, label, startOffsetMs)

public function SoundProfile.getPlayback() returns SoundPlayback
	return getPlaybackForLabel(this.getLabel())

public function createSound(string label, string filePath) returns ManagedSound
	let profile = new SoundProfile(filePath, label)
	return profile.createInstance(label)

function playSoundInternal(SoundProfile profile, vec3 pos, real range, string label, int startOffsetMs) returns SoundPlayback
	let playback = new SoundPlayback()
	if profile == null
		return playback
	let resolvedLabel = profile.resolveLabel(label)
	let center = pos.toVec2()
	for i = 0 to bj_MAX_PLAYERS - 1
		let hero = Unit.getHero(i)
		if hero != null and hero.isAlive()
			if hero.getPos().distanceTo(center) <= range
				let snd = profile.createInstance(resolvedLabel)
				snd.setPlayer(players[i])
				snd.setPosition(pos)
				if startOffsetMs != 0
					snd.setStartOffsetMs(startOffsetMs)
				snd.play()
				playback.add(snd)
	return playback

public function playSound(SoundProfile profile, vec3 pos, real range) returns SoundPlayback
	if profile == null
		return new SoundPlayback()
	return playSoundInternal(profile, pos, range, profile.getLabel(), 0)

public function playSound(SoundProfile profile, vec3 pos, real range, string label) returns SoundPlayback
	return playSoundInternal(profile, pos, range, label, 0)

public function playSoundFrom(SoundProfile profile, vec3 pos, real range, int startOffsetMs) returns SoundPlayback
	if profile == null
		return new SoundPlayback()
	return playSoundInternal(profile, pos, range, profile.getLabel(), startOffsetMs)

public function playSoundFrom(SoundProfile profile, vec3 pos, real range, string label, int startOffsetMs) returns SoundPlayback
	return playSoundInternal(profile, pos, range, label, startOffsetMs)
