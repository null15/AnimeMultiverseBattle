package Tether

import HashMap
import ClosureTimers

public class Tether
	static HashMap<unit, Tether> active = new HashMap<unit, Tether>()

	unit target
	unit anchor
	real maxDistance
	CallbackPeriodic cb
	CallbackSingle timeout
	bool finished

	construct(unit target, unit anchor, real maxDistance, real duration)
		if active.has(target)
			active.get(target).stop()
		this.target = target
		this.anchor = anchor
		this.maxDistance = maxDistance
		this.finished = false
		this.cb = doPeriodically(0.03125) (CallbackPeriodic c) ->
			this.update()
		active.put(target, this)
		if duration > 0
			let cbTimeout = doAfter(duration) ->
				this.timeout = null
				this.stop()
			this.timeout = cbTimeout

	function update()
		if this.finished
			return
		if this.target == null or not this.target.isAlive()
			stop()
			return
		if this.anchor == null or not this.anchor.isAlive()
			stop()
			return
		let diff = this.target.getPos() - this.anchor.getPos()
		let dist = diff.length()
		if dist > this.maxDistance
			this.target.setPos(this.anchor.getPos() + diff.norm() * (this.maxDistance - 10))

	function stop()
		if this.finished
			return
		this.finished = true
		if this.cb != null
			destroy this.cb
			this.cb = null
		if this.timeout != null
			destroy this.timeout
			this.timeout = null
		this.anchor.remove()
		active.remove(this.target)
		destroy this

	static function bind(unit target, unit anchor, real maxDistance) returns Tether
		if target == null or anchor == null
			return null
		return new Tether(target, anchor, maxDistance, -1)

	static function bindTimed(unit target, unit anchor, real maxDistance, real duration) returns Tether
		if target == null or anchor == null
			return null
		return new Tether(target, anchor, maxDistance, duration)

	ondestroy
		this.target = null
		this.anchor = null
		this.cb = null
		this.timeout = null