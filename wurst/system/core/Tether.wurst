package Tether

import HashMap
import ClosureTimers
import TimeStop

constant real TETHER_UPDATE_PERIOD = 0.03125

public class Tether
	static HashMap<unit, Tether> active = new HashMap<unit, Tether>()

	unit target
	unit anchor
	real maxDistance
	CallbackPeriodic cb
	bool finished
	bool hasDuration
	real remainingDuration

	construct(unit target, unit anchor, real maxDistance, real duration)
		if active.has(target)
			active.get(target).stop()
		this.target = target
		this.anchor = anchor
		this.maxDistance = maxDistance
		this.finished = false
		this.hasDuration = duration > 0
		this.remainingDuration = this.hasDuration ? duration : 0.
		this.cb = doPeriodically(TETHER_UPDATE_PERIOD) (CallbackPeriodic c) ->
			this.update()
		active.put(target, this)

	function update()
		if this.finished
			return
		if this.target == null or not this.target.isAlive()
			stop()
			return
		if this.anchor == null or not this.anchor.isAlive()
			stop()
			return
		if this.target.isTimeStopped()
			return
		if this.anchor.isTimeStopped()
			return
		if this.hasDuration
			this.remainingDuration -= TETHER_UPDATE_PERIOD
			if this.remainingDuration <= 0.
				this.stop()
				return
		let diff = this.target.getPos() - this.anchor.getPos()
		let dist = diff.length()
		if dist > this.maxDistance
			this.target.setPos(this.anchor.getPos() + diff.norm() * (this.maxDistance - 10))

	function stop()
		if this.finished
			return
		this.finished = true
		if this.cb != null
			destroy this.cb
			this.cb = null
		this.anchor.remove()
		active.remove(this.target)
		destroy this

	static function bind(unit target, unit anchor, real maxDistance) returns Tether
		if target == null or anchor == null
			return null
		return new Tether(target, anchor, maxDistance, -1)

	static function bindTimed(unit target, unit anchor, real maxDistance, real duration) returns Tether
		if target == null or anchor == null
			return null
		return new Tether(target, anchor, maxDistance, duration)

	ondestroy
		this.target = null
		this.anchor = null
		this.cb = null
