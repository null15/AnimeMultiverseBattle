package Nagato_Kuchiyose

import objectIDs
import HashMap
import Teleport
import ClosureTimers
import EntityManagement
import EntitySystem
import EffectsSystem
import SoundUtils
import SoundSystem

constant real SUMMON_CHANNEL_TIME = 3.
constant real ANIMAL_PATH_TELEPORT_RADIUS = 600.
constant real ANIMAL_PATH_TELEPORT_SPREAD = 128.
constant real ANIMAL_PATH_LINGER_DURATION = 0.70
constant real ANIMAL_PATH_TELEPORT_DELAY = 0.7
constant real ANIMAL_PATH_FINISH_ANIMATION_DELAY = 0.45
constant real CASTER_CHANNEL_ANIMATION_TIME_SCALE = 0.5
constant real CASTER_FINISH_ANIMATION_TIME_SCALE = 1.
constant real ANIMAL_PATH_CHANNEL_WIND_PERIOD = 0.3
constant real ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY = 1.5
constant angle ANIMAL_PATH_SOUTH_FACING = (270.).fromDeg()
constant string KUCHIYOSE_SCRIBBLE_MODEL_PATH = "Nagato\\Kuchiyose\\kuchiyose.mdx"
constant string KUCHIYOSE_TELEPORT_WIND_MODEL_PATH = "Nagato\\Kuchiyose\\KuchiyoseWind.mdx"
constant real KUCHIYOSE_TELEPORT_WIND_TIME_SCALE = 2.
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 = "Nagato\\Kuchiyose\\WindChannel1.mdx"
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2 = "Nagato\\Kuchiyose\\WindChannel2.mdx"
constant SoundDefinition snd_KuchiyoseHandSign = new SoundDefinition("Nagato\\Kuchiyose\\HandSign.mp3", false, true)
constant SoundDefinition snd_KuchiyoseSummoning = new SoundDefinition("Nagato\\Kuchiyose\\SummoningSoundEffect.mp3", false, true)
constant SoundDefinition snd_KuchiyosePoof = new SoundDefinition("Nagato\\Kuchiyose\\Poof.mp3", false, true)
constant SoundDefinition snd_KuchiyoseChant = new SoundDefinition("Nagato\\Kuchiyose\\AnimalPathChant.mp3", false, true)
constant real KUCHIYOSE_CHANT_DELAY = 2.75
constant real KUCHIYOSE_SOUND_RADIUS = 700.
constant real KUCHIYOSE_HANDSIGN_SOUND_PERIOD = 0.425
constant int KUCHIYOSE_HANDSIGN_SOUND_LIMIT = 6
constant real KUCHIYOSE_SUMMONING_SOUND_LEAD = 0.25
constant int ANIMATION_CHANNEL = 8
constant int ANIMATION_END = 17
constant HashMap<unit, SummonAnimalPath> active = new HashMap<unit, SummonAnimalPath>()

function releaseEffect(EffectsEntity entity) returns EffectsEntity
	return destroyEffectEntity(entity)

class SummonAnimalPath
	unit caster
	vec2 targetPos
	EffectsEntity scribble1
	EffectsEntity scribble2
	unit animalPath
	boolean finished
	LinkedList<EffectsEntity> channelWindEffects
	CallbackPeriodic channelWindTimer
	boolean nextChannelWindIsFirst
	CallbackPeriodic handSignSoundTimer
	int handSignSoundPlaysRemaining
	CallbackSingle chantSoundTimer

	construct(unit caster, vec2 targetPos)
		this.caster = caster
		this.targetPos = targetPos
		this.finished = false
		this.channelWindEffects = new LinkedList<EffectsEntity>
		this.handSignSoundPlaysRemaining = KUCHIYOSE_HANDSIGN_SOUND_LIMIT
		this.createVisuals()
		this.startChannelWindEffects()
		this.startHandSignSound()
		this.startChantSound()

	function createVisuals()
		let casterPos = this.getCasterEffectPos()
		this.animalPath = Unit.create(this.caster.getOwner(), NAGATO_ANIMAL_PATH_SUMMON, this.targetPos)..setScale(0.7)
		let animalPathPos = this.getAnimalPathEffectPos()
		this.scribble1 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, casterPos)
		if this.scribble1 != null
			let scribbleActor1 = this.scribble1.getActor()
			if scribbleActor1 != null
				scribbleActor1.playAnimation(ANIM_TYPE_STAND)
		this.scribble2 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, animalPathPos)
		if this.scribble2 != null
			let scribbleActor2 = this.scribble2.getActor()
			if scribbleActor2 != null
				scribbleActor2.playAnimation(ANIM_TYPE_STAND)
		if this.animalPath != null
			this.animalPath.setFacing(ANIMAL_PATH_SOUTH_FACING)
			this.animalPath..setAnimation(ANIMATION_CHANNEL)..setTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

	function getCasterEffectPos() returns vec3
		if this.caster == null
			return vec3(0, 0, 0)
		let casterEntity = this.caster.getEntity()
		return casterEntity != null ? casterEntity.getPos() : this.caster.getPos3Real()

	function getAnimalPathEffectPos() returns vec3
		if this.animalPath == null
			return vec3(0, 0, 0)
		let animalPathEntity = this.animalPath.getEntity()
		return animalPathEntity != null ? animalPathEntity.getPos() : this.animalPath.getPos3Real()

	function startChannelWindEffects()
		this.playChannelWindEffect(true)
		this.nextChannelWindIsFirst = false
		if ANIMAL_PATH_CHANNEL_WIND_PERIOD <= 0.
			return
		let inst = this
		this.channelWindTimer = doPeriodically(ANIMAL_PATH_CHANNEL_WIND_PERIOD) (CallbackPeriodic c) ->
			inst.playNextChannelWindEffect()

	function playNextChannelWindEffect()
		if this.caster == null
			return
		this.playChannelWindEffect(this.nextChannelWindIsFirst)
		this.nextChannelWindIsFirst = not this.nextChannelWindIsFirst

	function playChannelWindEffect(boolean playFirst)
		if this.caster == null
			return
		let casterPos		= this.getCasterEffectPos()
		let animalPathPos	= this.getAnimalPathEffectPos()
		let modelPath = playFirst ? KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 : KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2
		let effectInstance1 = this.createChannelWindEffect(modelPath, casterPos)
		let effectInstance2 = this.createChannelWindEffect(modelPath, animalPathPos)
		if effectInstance1 != null
			this.channelWindEffects.add(effectInstance1)
		if effectInstance2 != null
			this.channelWindEffects.add(effectInstance2)

	function createChannelWindEffect(string modelPath, vec3 pos) returns EffectsEntity
		let entity = addEffectEntity(modelPath, pos)
		if entity != null
			let actor = entity.getActor()
			if actor != null
				actor.setTime(0.)
				actor.playAnimation(ANIM_TYPE_BIRTH)
		return entity

	function stopChannelWindEffects()
		if this.channelWindTimer != null
			destroy this.channelWindTimer
			this.channelWindTimer = null
		this.releaseAllChannelWindEffects()

	function startHandSignSound()
		if not this.shouldContinueHandSignSound()
			return
		this.playHandSignSound()
		if KUCHIYOSE_HANDSIGN_SOUND_PERIOD <= 0.
			return
		let inst = this
		this.handSignSoundTimer = doPeriodically(KUCHIYOSE_HANDSIGN_SOUND_PERIOD) (CallbackPeriodic c) ->
			if inst.shouldContinueHandSignSound()
				inst.playHandSignSound()
			else
				inst.handSignSoundTimer = null
				destroy c

	function shouldContinueHandSignSound() returns boolean
		if this.finished
			return false
		if this.caster == null
			return false
		if not this.caster.isAlive()
			return false
		if KUCHIYOSE_HANDSIGN_SOUND_LIMIT > 0 and this.handSignSoundPlaysRemaining <= 0
			return false
		return true

	function playHandSignSound()
		playSound(snd_KuchiyoseHandSign, this.getCasterEffectPos(), KUCHIYOSE_SOUND_RADIUS)
		if KUCHIYOSE_HANDSIGN_SOUND_LIMIT > 0
			this.handSignSoundPlaysRemaining -= 1

	function stopHandSignSound()
		if this.handSignSoundTimer != null
			destroy this.handSignSoundTimer
			this.handSignSoundTimer = null

	function startChantSound()
		if KUCHIYOSE_CHANT_DELAY <= 0.
			this.playChantSound()
			return
		let inst = this
		this.chantSoundTimer = doAfter(KUCHIYOSE_CHANT_DELAY) ->
			inst.chantSoundTimer = null
			inst.playChantSound()

	function playChantSound()
		if this.finished
			return
		if this.caster == null or not this.caster.isAlive()
			return
		playSound(snd_KuchiyoseChant, this.getCasterEffectPos(), KUCHIYOSE_SOUND_RADIUS)

	function stopChantSound()
		if this.chantSoundTimer != null
			destroy this.chantSoundTimer
			this.chantSoundTimer = null

	function releaseAllChannelWindEffects()
		if this.channelWindEffects == null
			return
		for fx in this.channelWindEffects
			releaseEffect(fx)
		destroy this.channelWindEffects
		this.channelWindEffects = null

	function finish(boolean success)
		if this.finished
			return
		this.finished = true
		this.stopChannelWindEffects()
		this.stopHandSignSound()
		this.stopChantSound()
		if this.caster != null and active.has(this.caster)
			active.remove(this.caster)
		if success
			this.startSuccessfulFinish()
		else
			this.cancelFinish()

	function startSuccessfulFinish()
		this.playCasterFinishAnimation()
		this.playAnimalPathFinishAnimation()
		this.schedulePreTeleportSound()
		let inst = this
		doAfter(ANIMAL_PATH_TELEPORT_DELAY) ->
			inst.completeSuccessfulFinish()

	function schedulePreTeleportSound()
		let inst = this
		let delay = ANIMAL_PATH_TELEPORT_DELAY - KUCHIYOSE_SUMMONING_SOUND_LEAD
		if delay <= 0.
			inst.playSummoningSound()
		else
			doAfter(delay) ->
				inst.playSummoningSound()

	function playSummoningSound()
		if this.caster == null
			return
		playSound(snd_KuchiyoseSummoning, this.targetPos.toVec3(), KUCHIYOSE_SOUND_RADIUS)

	function completeSuccessfulFinish()
		this.teleportAllies()
		this.cleanupScribble()
		this.caster = null
		destroy this

	function cancelFinish()
		this.removeAnimalPathImmediate()
		this.cleanupScribble()
		this.playCasterFinishAnimation()
		this.caster = null
		destroy this

	function playCasterFinishAnimation()
		let casterUnit = this.caster
		if casterUnit != null
			nullTimer() ->
				if casterUnit != null and casterUnit.isAlive()
					casterUnit..setAnimation(ANIMATION_END)..setTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)

	function spawnTeleportWindAt(vec2 pos)
		let entity = addEffectEntity(KUCHIYOSE_TELEPORT_WIND_MODEL_PATH, pos.toVec3())
		if entity != null
			entity.setTimeScale(KUCHIYOSE_TELEPORT_WIND_TIME_SCALE)
			let actor = entity.getActor()
			if actor != null
				actor.playAnimation(ANIM_TYPE_BIRTH)
			doAfter(ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY) ->
				releaseEffect(entity)

	function teleportAllies()
		if this.caster == null or not this.caster.isAlive()
			this.removeAnimalPathImmediate()
			return
		let origin = this.caster.getPos()
		teleportUnitToPoint(this.caster, this.targetPos)
		teleportUnitsInRangeToPoint(origin, ANIMAL_PATH_TELEPORT_RADIUS, this.targetPos, (unit u) -> this.shouldTeleport(u), ANIMAL_PATH_TELEPORT_SPREAD)
		this.spawnTeleportWindAt(this.targetPos)
		this.playPoofSound()

	function playPoofSound()
		playSound(snd_KuchiyosePoof, this.targetPos.toVec3(), KUCHIYOSE_SOUND_RADIUS)

	function shouldTeleport(unit u) returns bool
		if u == null or not u.isAlive()
			return false
		if u == this.caster
			return false
		if not u.isType(UNIT_TYPE_HERO)
			return false
		if not this.caster.isAllyOf(u)
			return false
		return true

	function playAnimalPathFinishAnimation()
		let summon = this.animalPath
		this.animalPath = null
		if summon == null
			return
		summon..setAnimation(ANIMATION_END)..setTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)
		// doAfter(ANIMAL_PATH_FINISH_ANIMATION_DELAY) ->
			// summon.setAnimation(ANIMATION_END)
		doAfter(ANIMAL_PATH_LINGER_DURATION) ->
			if summon != null
				summon.remove()

	function removeAnimalPathImmediate()
		let summon = this.animalPath
		this.animalPath = null
		if summon != null
			summon.remove()

	function cleanupScribble()
		this.scribble1 = releaseEffect(this.scribble1)
		this.scribble2 = releaseEffect(this.scribble2)

	ondestroy
		this.stopChannelWindEffects()
		this.stopHandSignSound()
		this.stopChantSound()
		this.animalPath = null
		this.scribble1 = null
		this.scribble2 = null
		this.handSignSoundTimer = null
		this.chantSoundTimer = null

function onChannel()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster == null
			return
		let targetPos = EventData.getSpellTargetPos()
		if not caster.getOwner().hasVisibility(targetPos)
			printTimedToPlayer("Target area is not visible.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if not targetPos.isTerrainWalkable()
			printTimedToPlayer("Cannot summon there.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if active.has(caster)
			active.get(caster).finish(false)
		let inst = new SummonAnimalPath(caster, targetPos)
		active.put(caster, inst)
		nullTimer() ->
			if caster != null
				caster..setAnimation(ANIMATION_CHANNEL)..setTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

function onEnd()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).finish(false)

function onFinish()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).finish(true)

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEnd())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_FINISH, () -> onFinish())
