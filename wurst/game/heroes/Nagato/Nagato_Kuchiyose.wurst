package Nagato_Kuchiyose

import objectIDs
import HashMap
import Teleport
import ClosureTimers
import EntityManagement
import EntitySystem
import EffectsSystem
import SoundSystem
import TimeStopSpell
import HashSet
import TimeStop

constant real SUMMON_CHANNEL_TIME = 3.
constant real ANIMAL_PATH_TELEPORT_RADIUS = 600.
constant real ANIMAL_PATH_TELEPORT_SPREAD = 128.
constant real ANIMAL_PATH_LINGER_DURATION = 0.70
constant real ANIMAL_PATH_TELEPORT_DELAY = 0.7
constant real ANIMAL_PATH_FINISH_ANIMATION_DELAY = 0.45
constant real CASTER_CHANNEL_ANIMATION_TIME_SCALE = 0.5
constant real CASTER_FINISH_ANIMATION_TIME_SCALE = 1.
constant real ANIMAL_PATH_CHANNEL_WIND_PERIOD = 0.3
constant real ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY = 1.5
constant angle ANIMAL_PATH_SOUTH_FACING = (270.).fromDeg()
constant real KUCHIYOSE_TIME_STOP_UPDATE_PERIOD = 0.03125
constant string KUCHIYOSE_SCRIBBLE_MODEL_PATH = "Nagato\\Kuchiyose\\kuchiyose.mdx"
constant string KUCHIYOSE_TELEPORT_WIND_MODEL_PATH = "Nagato\\Kuchiyose\\KuchiyoseWind.mdx"
constant real KUCHIYOSE_TELEPORT_WIND_TIME_SCALE = 2.
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 = "Nagato\\Kuchiyose\\WindChannel1.mdx"
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2 = "Nagato\\Kuchiyose\\WindChannel2.mdx"
constant string SOUND_LABEL_KUCHIYOSE_HANDSIGN = "NagatoKuchiyoseHandSign"
constant SoundProfile snd_KuchiyoseHandSign = new SoundProfile("Nagato\\Kuchiyose\\HandSign.mp3", SOUND_LABEL_KUCHIYOSE_HANDSIGN, false, true)
constant string SOUND_LABEL_KUCHIYOSE_SUMMONING = "NagatoKuchiyoseSummoning"
constant SoundProfile snd_KuchiyoseSummoning = new SoundProfile("Nagato\\Kuchiyose\\SummoningSoundEffect.mp3", SOUND_LABEL_KUCHIYOSE_SUMMONING, false, true)
constant string SOUND_LABEL_KUCHIYOSE_POOF = "NagatoKuchiyosePoof"
constant SoundProfile snd_KuchiyosePoof = new SoundProfile("Nagato\\Kuchiyose\\Poof.mp3", SOUND_LABEL_KUCHIYOSE_POOF, false, true)
constant string SOUND_LABEL_KUCHIYOSE_CHANT = "NagatoKuchiyoseChant"
constant SoundProfile snd_KuchiyoseChant = new SoundProfile("Nagato\\Kuchiyose\\AnimalPathChant.mp3", SOUND_LABEL_KUCHIYOSE_CHANT, false, true)
constant real KUCHIYOSE_SOUND_RADIUS = 700.
constant int ANIMATION_CHANNEL = 8
constant int ANIMATION_END = 17
constant HashMap<unit, SummonAnimalPath> active = new HashMap<unit, SummonAnimalPath>()

class SummonAnimalPath extends ChannelSpell
	vec2 targetPos
	EffectTimeStopTracker scribble1Tracker
	EffectTimeStopTracker scribble2Tracker
	unit animalPath
	unit animalPathSoundSource
	boolean finished
	LinkedList<EffectTimeStopTracker> channelWindTrackers
	CallbackPeriodic channelWindTimer
	boolean nextChannelWindIsFirst
	boolean channelCompleted
	SoundPlayback summoningSound
	SoundPlayback chantSound
	SoundPlayback poofSound

	construct(unit caster, vec2 targetPos)
		super(caster, NAGATO_SUMMON_ANIMAL_PATH, KUCHIYOSE_TIME_STOP_UPDATE_PERIOD)
		this.targetPos = targetPos
		this.finished = false
		this.channelCompleted = false
		this.channelWindTrackers = new LinkedList<EffectTimeStopTracker>
		this.createVisuals()
		this.enableChannelExclusion()
		this.startChannelWindEffects()
		this.playHandSignSound()
		this.beginChannel(SUMMON_CHANNEL_TIME)
		this.startTicking()

	function hasCompletedChannel() returns boolean
		return this.channelCompleted

	override function shouldPauseChannel() returns boolean
		return this.anyTrackedUnitTimeStopped()

	function createVisuals()
		let casterUnit = this.getCaster()
		let casterPos = this.getCasterEffectPos()
		let owner = casterUnit != null ? casterUnit.getOwner() : null
		this.animalPath = Unit.create(owner, NAGATO_ANIMAL_PATH_SUMMON, this.targetPos)..setScale(0.7)
		this.animalPathSoundSource = this.animalPath
		if this.animalPath != null
			this.registerUnit(this.animalPath)
			this.registerTimeScaleSource(this.animalPath)
		let animalPathPos = this.getAnimalPathEffectPos()
		let scribble1 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, casterPos)
		let scribble2 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, animalPathPos)
		let watchers = new HashSet<unit>
		if casterUnit != null
			watchers.add(casterUnit)
		if this.animalPath != null
			watchers.add(this.animalPath)
		if scribble1 != null
			let scribbleActor1 = scribble1.getActor()
			if scribbleActor1 != null
				scribbleActor1.playAnimation(ANIM_TYPE_STAND)
			this.scribble1Tracker = this.registerEffectWithUnits(scribble1, watchers)
		if scribble2 != null
			let scribbleActor2 = scribble2.getActor()
			if scribbleActor2 != null
				scribbleActor2.playAnimation(ANIM_TYPE_STAND)
			this.scribble2Tracker = this.registerEffectWithUnits(scribble2, watchers)
		destroy watchers
		if this.animalPath != null
			this.animalPath.setFacing(ANIMAL_PATH_SOUTH_FACING)
			this.animalPath..setAnimation(ANIMATION_CHANNEL)..setEntityTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

	function getCasterEffectPos() returns vec3
		let casterUnit = this.getCaster()
		if casterUnit == null
			return vec3(0, 0, 0)
		let casterEntity = casterUnit.getEntity()
		return casterEntity != null ? casterEntity.getPos() : casterUnit.getPos3Real()

	function getAnimalPathEffectPos() returns vec3
		if this.animalPath == null
			return vec3(0, 0, 0)
		let animalPathEntity = this.animalPath.getEntity()
		return animalPathEntity != null ? animalPathEntity.getPos() : this.animalPath.getPos3Real()

	function startChannelWindEffects()
		this.playChannelWindEffect(true)
		this.nextChannelWindIsFirst = false
		if ANIMAL_PATH_CHANNEL_WIND_PERIOD <= 0.
			return
		let inst = this
		this.channelWindTimer = doPeriodically(ANIMAL_PATH_CHANNEL_WIND_PERIOD) (CallbackPeriodic c) ->
			inst.playNextChannelWindEffect()

	function playNextChannelWindEffect()
		if this.getCaster() == null
			return
		this.playChannelWindEffect(this.nextChannelWindIsFirst)
		this.nextChannelWindIsFirst = not this.nextChannelWindIsFirst

	function playChannelWindEffect(boolean playFirst)
		let casterUnit = this.getCaster()
		if casterUnit == null
			return
		let casterPos           = this.getCasterEffectPos()
		let animalPathPos       = this.getAnimalPathEffectPos()
		let modelPath = playFirst ? KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 : KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2
		let effectInstance1 = this.createChannelWindEffect(modelPath, casterPos)
		let effectInstance2 = this.createChannelWindEffect(modelPath, animalPathPos)
		let watchers = new HashSet<unit>
		watchers.add(casterUnit)
		if this.animalPath != null
			watchers.add(this.animalPath)
		if effectInstance1 != null
			let tracker1 = this.registerEffectWithUnits(effectInstance1, watchers)
			if this.channelWindTrackers != null and tracker1 != null
				this.channelWindTrackers.add(tracker1)
		if effectInstance2 != null
			let tracker2 = this.registerEffectWithUnits(effectInstance2, watchers)
			if this.channelWindTrackers != null and tracker2 != null
				this.channelWindTrackers.add(tracker2)
		destroy watchers

	function createChannelWindEffect(string modelPath, vec3 pos) returns EffectsEntity
		let entity = addEffectEntity(modelPath, pos)
		if entity != null
			let actor = entity.getActor()
			if actor != null
				actor.setTime(0.)
				actor.playAnimation(ANIM_TYPE_BIRTH)
		return entity

	function stopChannelWindEffects()
		if this.channelWindTimer != null
			destroy this.channelWindTimer
			this.channelWindTimer = null
		this.releaseAllChannelWindEffects()

	function getAnimalPathSoundPos() returns vec3
		if this.animalPath != null
			return this.getAnimalPathEffectPos()
		return this.targetPos.toVec3()

	function playSoundForAnimalPath(SoundProfile profile) returns ChannelSoundPlayback
		if profile == null
			return null
		let summon = this.animalPath != null ? this.animalPath : this.animalPathSoundSource
		if summon == null
			return null
		return profile.playChannelForUnit(summon, 0, KUCHIYOSE_SOUND_RADIUS)

	function playSoundAtAnimalPath(SoundProfile profile) returns SoundPlayback
		if profile == null
			return null
		return profile.playAt(this.getAnimalPathSoundPos(), KUCHIYOSE_SOUND_RADIUS)

	function stopSoundPlayback(SoundPlayback playback) returns SoundPlayback
		if playback != null
			playback.stopAll()
		return null

	function playHandSignSound()
		this.setChannelSound(this.playSoundForAnimalPath(snd_KuchiyoseHandSign))

	function stopHandSignSound()
		this.stopChannelSound()

	function playCastEndSounds()
		this.stopHandSignSound()
		this.summoningSound = this.playSoundAtAnimalPath(snd_KuchiyoseSummoning)
		this.chantSound = this.playSoundAtAnimalPath(snd_KuchiyoseChant)

	function stopSummoningSound()
		this.summoningSound = this.stopSoundPlayback(this.summoningSound)

	function stopChantSound()
		this.chantSound = this.stopSoundPlayback(this.chantSound)

	function stopPoofSound()
		this.poofSound = this.stopSoundPlayback(this.poofSound)

	function releaseAllChannelWindEffects()
		if this.channelWindTrackers == null
			return
		for tracker in this.channelWindTrackers
			if tracker != null
				tracker.release()
		this.channelWindTrackers.clear()

	override function onChannelFinish(boolean orderCaster) returns boolean
		this.handleFinish(orderCaster)
		return false

	function handleFinish(boolean success)
		if this.finished
			return
		this.finished = true
		this.channelCompleted = success
		this.stopChannelWindEffects()
		if not success
			this.stopHandSignSound()
			this.stopSummoningSound()
			this.stopChantSound()
			this.stopPoofSound()
		let casterUnit = this.getCaster()
		if casterUnit != null and active.has(casterUnit)
			if active.get(casterUnit) == this
				active.remove(casterUnit)
		if success
			this.playCastEndSounds()
			this.startSuccessfulFinish()
		else
			this.cancelFinish()

	function startSuccessfulFinish()
		this.playCasterFinishAnimation()
		this.playAnimalPathFinishAnimation()
		let inst = this
		doAfter(ANIMAL_PATH_TELEPORT_DELAY) ->
			inst.completeSuccessfulFinish()

	function completeSuccessfulFinish()
		this.teleportAllies()
		this.cleanupScribble()
		this.summoningSound = null
		this.chantSound = null
		this.poofSound = null
		this.finishSpell()

	function cancelFinish()
		this.removeAnimalPathImmediate()
		this.cleanupScribble()
		this.playCasterFinishAnimation()
		this.finishSpell()

	function playCasterFinishAnimation()
		let casterUnit = this.getCaster()
		if casterUnit != null
			nullTimer() ->
				if casterUnit != null and casterUnit.isAlive() and not casterUnit.isTimeStopped()
					casterUnit..setAnimation(ANIMATION_END)..setEntityTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)

	function spawnTeleportWindAt(vec2 pos)
		let entity = addEffectEntity(KUCHIYOSE_TELEPORT_WIND_MODEL_PATH, pos.toVec3())
		if entity != null
			entity.setTimeScale(KUCHIYOSE_TELEPORT_WIND_TIME_SCALE)
			let actor = entity.getActor()
			if actor != null
				actor.playAnimation(ANIM_TYPE_BIRTH)
			let watchers = new HashSet<unit>
			let casterUnit = this.getCaster()
			if casterUnit != null
				watchers.add(casterUnit)
			if this.animalPath != null
				watchers.add(this.animalPath)
			let tracker = this.registerEffectWithUnits(entity, watchers)
			destroy watchers
			doAfter(ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY) ->
				if tracker != null
					tracker.release()

	function teleportAllies()
		let casterUnit = this.getCaster()
		if casterUnit == null or not casterUnit.isAlive()
			this.removeAnimalPathImmediate()
			return
		let origin = casterUnit.getPos()
		teleportUnitToPoint(casterUnit, this.targetPos)
		teleportUnitsInRangeToPoint(origin, ANIMAL_PATH_TELEPORT_RADIUS, this.targetPos, (unit u) -> this.shouldTeleport(u), ANIMAL_PATH_TELEPORT_SPREAD)
		this.spawnTeleportWindAt(this.targetPos)
		this.playPoofSound()

	function playPoofSound()
		this.poofSound = this.playSoundAtAnimalPath(snd_KuchiyosePoof)

	function shouldTeleport(unit u) returns bool
		if u == null or not u.isAlive()
			return false
		let casterUnit = this.getCaster()
		if u == casterUnit
			return false
		if not u.isType(UNIT_TYPE_HERO)
			return false
		if casterUnit == null or not casterUnit.isAllyOf(u)
			return false
		return true

	function playAnimalPathFinishAnimation()
		let summon = this.animalPath
		if summon == null
			return
		summon..setAnimation(ANIMATION_END)..setEntityTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)
		let inst = this
		doAfter(ANIMAL_PATH_LINGER_DURATION) ->
			if summon != null
				summon.remove()
			if inst.animalPath == summon
				inst.animalPath = null
			if inst.animalPathSoundSource == summon
				inst.animalPathSoundSource = null

	function removeAnimalPathImmediate()
		let summon = this.animalPath
		this.animalPath = null
		if summon != null
			summon.remove()
		if this.animalPathSoundSource == summon
			this.animalPathSoundSource = null

	function cleanupScribble()
		if this.scribble1Tracker != null
			this.scribble1Tracker.release()
			this.scribble1Tracker = null
		if this.scribble2Tracker != null
			this.scribble2Tracker.release()
			this.scribble2Tracker = null

	override function onCleanup()
		this.stopChannelWindEffects()
		this.stopHandSignSound()
		this.stopSummoningSound()
		this.stopChantSound()
		this.stopPoofSound()
		this.releaseAllChannelWindEffects()
		this.cleanupScribble()
		if this.channelWindTrackers != null
			destroy this.channelWindTrackers
			this.channelWindTrackers = null
		let casterUnit = this.getCaster()
		if casterUnit != null and active.has(casterUnit)
			if active.get(casterUnit) == this
				active.remove(casterUnit)
		this.animalPath = null
		this.animalPathSoundSource = null
		this.summoningSound = null
		this.chantSound = null
		this.poofSound = null
		this.channelWindTimer = null

function onChannel()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster == null
			return
		let targetPos = EventData.getSpellTargetPos()
		if not caster.getOwner().hasVisibility(targetPos)
			printTimedToPlayer("Target area is not visible.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if not targetPos.isTerrainWalkable()
			printTimedToPlayer("Cannot summon there.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if active.has(caster)
			active.get(caster).finishChannel(false)
		let inst = new SummonAnimalPath(caster, targetPos)
		if inst != null and inst.isChannelActive()
			active.put(caster, inst)
			nullTimer() ->
				if caster != null
					caster..setAnimation(ANIMATION_CHANNEL)..setEntityTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")
		else if inst != null
			destroy inst

function onEnd()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			let inst = active.get(caster)
			if inst != null
				inst.finishChannel(inst.hasCompletedChannel())

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEnd())