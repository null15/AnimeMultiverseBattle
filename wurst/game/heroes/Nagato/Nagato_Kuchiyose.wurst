package Nagato_Kuchiyose

import objectIDs
import HashMap
import Teleport
import ClosureTimers
import EntityManagement
import EntitySystem
import EffectsSystem
import SoundSystem
import TimeStop

constant real SUMMON_CHANNEL_TIME = 3.
constant real ANIMAL_PATH_TELEPORT_RADIUS = 600.
constant real ANIMAL_PATH_TELEPORT_SPREAD = 128.
constant real ANIMAL_PATH_LINGER_DURATION = 0.70
constant real ANIMAL_PATH_TELEPORT_DELAY = 0.7
constant real ANIMAL_PATH_FINISH_ANIMATION_DELAY = 0.45
constant real CASTER_CHANNEL_ANIMATION_TIME_SCALE = 0.5
constant real CASTER_FINISH_ANIMATION_TIME_SCALE = 1.
constant real ANIMAL_PATH_CHANNEL_WIND_PERIOD = 0.3
constant real ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY = 1.5
constant angle ANIMAL_PATH_SOUTH_FACING = (270.).fromDeg()
constant real KUCHIYOSE_TIME_STOP_UPDATE_PERIOD = 0.03125
constant string KUCHIYOSE_SCRIBBLE_MODEL_PATH = "Nagato\\Kuchiyose\\kuchiyose.mdx"
constant string KUCHIYOSE_TELEPORT_WIND_MODEL_PATH = "Nagato\\Kuchiyose\\KuchiyoseWind.mdx"
constant real KUCHIYOSE_TELEPORT_WIND_TIME_SCALE = 2.
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 = "Nagato\\Kuchiyose\\WindChannel1.mdx"
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2 = "Nagato\\Kuchiyose\\WindChannel2.mdx"
constant string SOUND_LABEL_KUCHIYOSE_HANDSIGN = "NagatoKuchiyoseHandSign"
constant SoundProfile snd_KuchiyoseHandSign = new SoundProfile("Nagato\\Kuchiyose\\HandSign.mp3", SOUND_LABEL_KUCHIYOSE_HANDSIGN, false, true)
constant string SOUND_LABEL_KUCHIYOSE_SUMMONING = "NagatoKuchiyoseSummoning"
constant SoundProfile snd_KuchiyoseSummoning = new SoundProfile("Nagato\\Kuchiyose\\SummoningSoundEffect.mp3", SOUND_LABEL_KUCHIYOSE_SUMMONING, false, true)
constant string SOUND_LABEL_KUCHIYOSE_POOF = "NagatoKuchiyosePoof"
constant SoundProfile snd_KuchiyosePoof = new SoundProfile("Nagato\\Kuchiyose\\Poof.mp3", SOUND_LABEL_KUCHIYOSE_POOF, false, true)
constant string SOUND_LABEL_KUCHIYOSE_CHANT = "NagatoKuchiyoseChant"
constant SoundProfile snd_KuchiyoseChant = new SoundProfile("Nagato\\Kuchiyose\\AnimalPathChant.mp3", SOUND_LABEL_KUCHIYOSE_CHANT, false, true)
constant real KUCHIYOSE_SOUND_RADIUS = 700.
constant int ANIMATION_CHANNEL = 8
constant int ANIMATION_END = 17
constant HashMap<unit, SummonAnimalPath> active = new HashMap<unit, SummonAnimalPath>()

function releaseEffect(EffectsEntity entity) returns EffectsEntity
	return destroyEffectEntity(entity)

class SummonAnimalPath
	unit caster
	vec2 targetPos
	EffectsEntity scribble1
	EffectsEntity scribble2
	unit animalPath
	unit animalPathSoundSource
	boolean finished
	LinkedList<EffectsEntity> channelWindEffects
	CallbackPeriodic channelWindTimer
	boolean nextChannelWindIsFirst
	CallbackPeriodic timeStopTimer
	boolean effectsTimeStopped
	boolean channelCompleted
	real casterTimeScaleBeforeOverride
	boolean casterTimeScaleOverridden
	ChannelSoundPlayback handSignSound
	SoundPlayback summoningSound
	SoundPlayback chantSound
	SoundPlayback poofSound

	construct(unit caster, vec2 targetPos)
		this.caster = caster
		this.targetPos = targetPos
		this.finished = false
		this.channelCompleted = false
		this.channelWindEffects = new LinkedList<EffectsEntity>
		this.createVisuals()
		this.startChannelWindEffects()
		this.playHandSignSound()
		this.startTimeStopUpdates()

	function hasCompletedChannel() returns boolean
		return this.channelCompleted

	function createVisuals()
		let casterPos = this.getCasterEffectPos()
		this.animalPath = Unit.create(this.caster.getOwner(), NAGATO_ANIMAL_PATH_SUMMON, this.targetPos)..setScale(0.7)
		this.animalPathSoundSource = this.animalPath
		let animalPathPos = this.getAnimalPathEffectPos()
		this.scribble1 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, casterPos)
		if this.scribble1 != null
			let scribbleActor1 = this.scribble1.getActor()
			if scribbleActor1 != null
				scribbleActor1.playAnimation(ANIM_TYPE_STAND)
		this.scribble2 = addEffectEntity(KUCHIYOSE_SCRIBBLE_MODEL_PATH, animalPathPos)
		if this.scribble2 != null
			let scribbleActor2 = this.scribble2.getActor()
			if scribbleActor2 != null
				scribbleActor2.playAnimation(ANIM_TYPE_STAND)
		if this.animalPath != null
			this.animalPath.setFacing(ANIMAL_PATH_SOUTH_FACING)
			this.animalPath..setAnimation(ANIMATION_CHANNEL)..setEntityTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

	function startEffectTimeStop(EffectsEntity entity)
		if entity == null
			return
		let fx = entity.getActor()
		if fx != null
			fx.startTimeStop()

	function stopEffectTimeStop(EffectsEntity entity)
		if entity == null
			return
		let fx = entity.getActor()
		if fx != null
			fx.stopTimeStop()

	function startEffectsTimeStop()
		this.startEffectTimeStop(this.scribble1)
		this.startEffectTimeStop(this.scribble2)
		if this.channelWindEffects != null
			for fx in this.channelWindEffects
				this.startEffectTimeStop(fx)

	function stopEffectsTimeStop()
		this.stopEffectTimeStop(this.scribble1)
		this.stopEffectTimeStop(this.scribble2)
		if this.channelWindEffects != null
			for fx in this.channelWindEffects
				this.stopEffectTimeStop(fx)
		this.effectsTimeStopped = false

	function updateEffectsTimeStop(boolean active)
		if active
			if not this.effectsTimeStopped
				this.effectsTimeStopped = true
				this.startEffectsTimeStop()
		else if this.effectsTimeStopped
			this.effectsTimeStopped = false
			this.stopEffectsTimeStop()

	function shouldOverrideCasterTimeScale() returns boolean
		let casterUnit = this.caster
		if casterUnit == null
			return false
		if not casterUnit.isAlive()
			return false
		if casterUnit.isTimeStopped()
			return false
		let summon = this.animalPath
		if summon == null
			return false
		return summon.isTimeStopped()

	function startCasterTimeScaleOverride()
		if this.casterTimeScaleOverridden
			return
		let casterUnit = this.caster
		if casterUnit == null
			return
		this.casterTimeScaleBeforeOverride = casterUnit.getEntityTimeScale()
		casterUnit.setEntityTimeScale(0.)
		this.casterTimeScaleOverridden = true

	function stopCasterTimeScaleOverride()
		if not this.casterTimeScaleOverridden
			return
		let casterUnit = this.caster
		if casterUnit != null
			casterUnit.setEntityTimeScale(this.casterTimeScaleBeforeOverride)
		this.casterTimeScaleOverridden = false

	function updateCasterTimeScaleOverride()
		if this.shouldOverrideCasterTimeScale()
			this.startCasterTimeScaleOverride()
		else
			this.stopCasterTimeScaleOverride()

	function isTimeStopActive() returns boolean
		if this.caster != null and this.caster.isTimeStopped()
			return true
		if this.animalPath != null and this.animalPath.isTimeStopped()
			return true
		return false

	function updateTimeStopState()
		let isStopped = this.isTimeStopActive()
		this.updateEffectsTimeStop(isStopped)
		this.updateCasterTimeScaleOverride()

	function updateChannelProgress()
		if this.finished
			return
		let casterUnit = this.caster
		if casterUnit == null
			this.finish(false)
			return
		if not casterUnit.isAlive()
			this.finish(false)
			return
		if not casterUnit.isChannelingAbility(NAGATO_SUMMON_ANIMAL_PATH)
			if this.channelCompleted
				this.finish(true)
			else
				this.finish(false)
			return
		if this.shouldPauseChannelDueToTimeStop()
			return
		casterUnit.consumeChannelTime(NAGATO_SUMMON_ANIMAL_PATH, KUCHIYOSE_TIME_STOP_UPDATE_PERIOD)
		if not this.channelCompleted and casterUnit.getChannelRemaining(NAGATO_SUMMON_ANIMAL_PATH) <= 0.
			this.channelCompleted = true
			this.finish(true)

	function onPeriodicUpdate()
		this.updateTimeStopState()
		this.updateChannelProgress()

	function shouldPauseChannelDueToTimeStop() returns boolean
		if this.animalPath != null and this.animalPath.isTimeStopped()
			return true
		return false

	function startTimeStopUpdates()
		if this.timeStopTimer != null
			return
		let inst = this
		this.timeStopTimer = doPeriodically(KUCHIYOSE_TIME_STOP_UPDATE_PERIOD) (CallbackPeriodic c) ->
			inst.onPeriodicUpdate()
		this.onPeriodicUpdate()

	function stopTimeStopUpdates()
		if this.timeStopTimer != null
			destroy this.timeStopTimer
			this.timeStopTimer = null

	function getCasterEffectPos() returns vec3
		if this.caster == null
			return vec3(0, 0, 0)
		let casterEntity = this.caster.getEntity()
		return casterEntity != null ? casterEntity.getPos() : this.caster.getPos3Real()

	function getAnimalPathEffectPos() returns vec3
		if this.animalPath == null
			return vec3(0, 0, 0)
		let animalPathEntity = this.animalPath.getEntity()
		return animalPathEntity != null ? animalPathEntity.getPos() : this.animalPath.getPos3Real()

	function startChannelWindEffects()
		this.playChannelWindEffect(true)
		this.nextChannelWindIsFirst = false
		if ANIMAL_PATH_CHANNEL_WIND_PERIOD <= 0.
			return
		let inst = this
		this.channelWindTimer = doPeriodically(ANIMAL_PATH_CHANNEL_WIND_PERIOD) (CallbackPeriodic c) ->
			inst.playNextChannelWindEffect()

	function playNextChannelWindEffect()
		if this.caster == null
			return
		this.playChannelWindEffect(this.nextChannelWindIsFirst)
		this.nextChannelWindIsFirst = not this.nextChannelWindIsFirst

	function playChannelWindEffect(boolean playFirst)
		if this.caster == null
			return
		let casterPos		= this.getCasterEffectPos()
		let animalPathPos	= this.getAnimalPathEffectPos()
		let modelPath = playFirst ? KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 : KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2
		let effectInstance1 = this.createChannelWindEffect(modelPath, casterPos)
		let effectInstance2 = this.createChannelWindEffect(modelPath, animalPathPos)
		if effectInstance1 != null
			if this.effectsTimeStopped
				this.startEffectTimeStop(effectInstance1)
			this.channelWindEffects.add(effectInstance1)
		if effectInstance2 != null
			if this.effectsTimeStopped
				this.startEffectTimeStop(effectInstance2)
			this.channelWindEffects.add(effectInstance2)

	function createChannelWindEffect(string modelPath, vec3 pos) returns EffectsEntity
		let entity = addEffectEntity(modelPath, pos)
		if entity != null
			let actor = entity.getActor()
			if actor != null
				actor.setTime(0.)
				actor.playAnimation(ANIM_TYPE_BIRTH)
		return entity

	function stopChannelWindEffects()
		if this.channelWindTimer != null
			destroy this.channelWindTimer
			this.channelWindTimer = null
		this.releaseAllChannelWindEffects()

	function getAnimalPathSoundPos() returns vec3
		if this.animalPath != null
			return this.getAnimalPathEffectPos()
		return this.targetPos.toVec3()

	function playSoundForAnimalPath(SoundProfile profile) returns ChannelSoundPlayback
		if profile == null
			return null
		let summon = this.animalPath != null ? this.animalPath : this.animalPathSoundSource
		if summon == null
			return null
		return profile.playChannelForUnit(summon, 0, KUCHIYOSE_SOUND_RADIUS)

	function playSoundAtAnimalPath(SoundProfile profile) returns SoundPlayback
		if profile == null
			return null
		return profile.playAt(this.getAnimalPathSoundPos(), KUCHIYOSE_SOUND_RADIUS)

	function stopChannelSound(ChannelSoundPlayback channel) returns ChannelSoundPlayback
		if channel != null
			channel.stop()
		return null

	function stopSoundPlayback(SoundPlayback playback) returns SoundPlayback
		if playback != null
			playback.stopAll()
		return null

	function playHandSignSound()
		this.handSignSound = this.playSoundForAnimalPath(snd_KuchiyoseHandSign)

	function stopHandSignSound()
		this.handSignSound = this.stopChannelSound(this.handSignSound)

	function playCastEndSounds()
		this.stopHandSignSound()
		this.summoningSound = this.playSoundAtAnimalPath(snd_KuchiyoseSummoning)
		this.chantSound = this.playSoundAtAnimalPath(snd_KuchiyoseChant)

	function stopSummoningSound()
		this.summoningSound = this.stopSoundPlayback(this.summoningSound)

	function stopChantSound()
		this.chantSound = this.stopSoundPlayback(this.chantSound)

	function stopPoofSound()
		this.poofSound = this.stopSoundPlayback(this.poofSound)

	function releaseAllChannelWindEffects()
		if this.channelWindEffects == null
			return
		for fx in this.channelWindEffects
			releaseEffect(fx)
		destroy this.channelWindEffects
		this.channelWindEffects = null

	function finish(boolean success)
		if this.finished
			return
		this.finished = true
		this.stopCasterTimeScaleOverride()
		this.stopTimeStopUpdates()
		if this.effectsTimeStopped
			this.stopEffectsTimeStop()
		this.stopChannelWindEffects()
		if not success
			this.stopHandSignSound()
			this.stopSummoningSound()
			this.stopChantSound()
			this.stopPoofSound()
		if this.caster != null
			if active.has(this.caster)
				active.remove(this.caster)
			if success
				this.caster.finishChanneling(NAGATO_SUMMON_ANIMAL_PATH)
			else
				this.caster.clearChanneling(NAGATO_SUMMON_ANIMAL_PATH)
		if success
			this.playCastEndSounds()
			this.startSuccessfulFinish()
		else
			this.cancelFinish()

	function startSuccessfulFinish()
		this.playCasterFinishAnimation()
		this.playAnimalPathFinishAnimation()
		let inst = this
		doAfter(ANIMAL_PATH_TELEPORT_DELAY) ->
			inst.completeSuccessfulFinish()

	function completeSuccessfulFinish()
		this.teleportAllies()
		this.cleanupScribble()
		this.summoningSound = null
		this.chantSound = null
		this.poofSound = null
		this.caster = null
		destroy this

	function cancelFinish()
		this.removeAnimalPathImmediate()
		this.cleanupScribble()
		this.playCasterFinishAnimation()
		this.caster = null
		destroy this

	function playCasterFinishAnimation()
		let casterUnit = this.caster
		if casterUnit != null
			nullTimer() ->
				if casterUnit != null and casterUnit.isAlive() and not casterUnit.isTimeStopped()
					casterUnit..setAnimation(ANIMATION_END)..setEntityTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)

	function spawnTeleportWindAt(vec2 pos)
		let entity = addEffectEntity(KUCHIYOSE_TELEPORT_WIND_MODEL_PATH, pos.toVec3())
		if entity != null
			entity.setTimeScale(KUCHIYOSE_TELEPORT_WIND_TIME_SCALE)
			let actor = entity.getActor()
			if actor != null
				actor.playAnimation(ANIM_TYPE_BIRTH)
			if this.effectsTimeStopped
				this.startEffectTimeStop(entity)
			doAfter(ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY) ->
				releaseEffect(entity)

	function teleportAllies()
		if this.caster == null or not this.caster.isAlive()
			this.removeAnimalPathImmediate()
			return
		let origin = this.caster.getPos()
		teleportUnitToPoint(this.caster, this.targetPos)
		teleportUnitsInRangeToPoint(origin, ANIMAL_PATH_TELEPORT_RADIUS, this.targetPos, (unit u) -> this.shouldTeleport(u), ANIMAL_PATH_TELEPORT_SPREAD)
		this.spawnTeleportWindAt(this.targetPos)
		this.playPoofSound()

	function playPoofSound()
		this.poofSound = this.playSoundAtAnimalPath(snd_KuchiyosePoof)

	function shouldTeleport(unit u) returns bool
		if u == null or not u.isAlive()
			return false
		if u == this.caster
			return false
		if not u.isType(UNIT_TYPE_HERO)
			return false
		if not this.caster.isAllyOf(u)
			return false
		return true

	function playAnimalPathFinishAnimation()
		let summon = this.animalPath
		if summon == null
			return
		summon..setAnimation(ANIMATION_END)..setEntityTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)
		let inst = this
		doAfter(ANIMAL_PATH_LINGER_DURATION) ->
			if summon != null
				summon.remove()
			if inst.animalPath == summon
				inst.animalPath = null
			if inst.animalPathSoundSource == summon
				inst.animalPathSoundSource = null

	function removeAnimalPathImmediate()
		let summon = this.animalPath
		this.animalPath = null
		if summon != null
			summon.remove()
		if this.animalPathSoundSource == summon
			this.animalPathSoundSource = null

	function cleanupScribble()
		this.scribble1 = releaseEffect(this.scribble1)
		this.scribble2 = releaseEffect(this.scribble2)

	ondestroy
		if this.effectsTimeStopped
			this.stopEffectsTimeStop()
		this.stopChannelWindEffects()
		this.stopHandSignSound()
		this.stopSummoningSound()
		this.stopChantSound()
		this.stopPoofSound()
		this.stopTimeStopUpdates()
		this.stopCasterTimeScaleOverride()
		this.effectsTimeStopped = false
		this.animalPath = null
		this.animalPathSoundSource = null
		this.scribble1 = null
		this.scribble2 = null

function onChannel()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster == null
			return
		let targetPos = EventData.getSpellTargetPos()
		if not caster.getOwner().hasVisibility(targetPos)
			printTimedToPlayer("Target area is not visible.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if not targetPos.isTerrainWalkable()
			printTimedToPlayer("Cannot summon there.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if active.has(caster)
			active.get(caster).finish(false)
		caster.startChanneling(NAGATO_SUMMON_ANIMAL_PATH, SUMMON_CHANNEL_TIME)
		let inst = new SummonAnimalPath(caster, targetPos)
		active.put(caster, inst)
		nullTimer() ->
			if caster != null
				caster..setAnimation(ANIMATION_CHANNEL)..setEntityTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

function onEnd()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			let inst = active.get(caster)
			if inst != null
				inst.finish(inst.hasCompletedChannel())

init
	registerTimeStopChannelExclusion(NAGATO_SUMMON_ANIMAL_PATH)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEnd())
