package Nagato_Kuchiyose

import objectIDs
import HashMap
import Teleport
import ClosureTimers
import EntityManagement
import EntitySystem

constant real SUMMON_CHANNEL_TIME = 3.
constant real ANIMAL_PATH_TELEPORT_RADIUS = 600.
constant real ANIMAL_PATH_TELEPORT_SPREAD = 128.
constant real ANIMAL_PATH_LINGER_DURATION = 0.70
constant real ANIMAL_PATH_TELEPORT_DELAY = 0.7
constant real ANIMAL_PATH_FINISH_ANIMATION_DELAY = 0.45
constant real CASTER_CHANNEL_ANIMATION_TIME_SCALE = 0.5
constant real CASTER_FINISH_ANIMATION_TIME_SCALE = 1.
constant real ANIMAL_PATH_CHANNEL_WIND_PERIOD = 0.3
constant real ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY = 1.5
constant angle ANIMAL_PATH_SOUTH_FACING = (270.).fromDeg()
constant string KUCHIYOSE_SCRIBBLE_MODEL_PATH = "Nagato\\Kuchiyose\\kuchiyose.mdx"
constant string KUCHIYOSE_TELEPORT_WIND_MODEL_PATH = "Nagato\\Kuchiyose\\KuchiyoseWind.mdx"
constant real KUCHIYOSE_TELEPORT_WIND_TIME_SCALE = 2.
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 = "Nagato\\Kuchiyose\\WindChannel1.mdx"
constant string KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2 = "Nagato\\Kuchiyose\\WindChannel2.mdx"
constant int ANIMATION_CHANNEL = 8
constant int ANIMATION_END = 17
constant HashMap<unit, SummonAnimalPath> active = new HashMap<unit, SummonAnimalPath>()

function releaseEffect(effect fx) returns effect
	if fx != null
		fx..setPos(vec2(-99999, -99999))..destr()
	return null

class SummonAnimalPath
	unit caster
	vec2 targetPos
	effect scribble1
	effect scribble2
	unit animalPath
	boolean finished
	LinkedList<effect> channelWindEffects
	CallbackPeriodic channelWindTimer
	boolean nextChannelWindIsFirst

	construct(unit caster, vec2 targetPos)
		this.caster = caster
		this.targetPos = targetPos
		this.finished = false
		this.channelWindEffects = new LinkedList<effect>
		this.createVisuals()
		this.startChannelWindEffects()

	function createVisuals()
		let casterPos = this.getCasterEffectPos()
		this.animalPath = Unit.create(this.caster.getOwner(), NAGATO_ANIMAL_PATH_SUMMON, this.targetPos)..setScale(0.7)
		let animalPathPos = this.getAnimalPathEffectPos()
		this.scribble1 = addEffect(KUCHIYOSE_SCRIBBLE_MODEL_PATH, casterPos)..playAnimation(ANIM_TYPE_STAND)
		this.scribble2 = addEffect(KUCHIYOSE_SCRIBBLE_MODEL_PATH, animalPathPos)..playAnimation(ANIM_TYPE_STAND)
		if this.animalPath != null
			this.animalPath.setFacing(ANIMAL_PATH_SOUTH_FACING)
			this.animalPath..setAnimation(ANIMATION_CHANNEL)..setTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

	function getCasterEffectPos() returns vec3
		if this.caster == null
			return vec3(0, 0, 0)
		let casterEntity = this.caster.getEntity()
		return casterEntity != null ? casterEntity.getPos() : this.caster.getPos3Real()

	function getAnimalPathEffectPos() returns vec3
		if this.animalPath == null
			return vec3(0, 0, 0)
		let animalPathEntity = this.animalPath.getEntity()
		return animalPathEntity != null ? animalPathEntity.getPos() : this.animalPath.getPos3Real()

	function startChannelWindEffects()
		this.playChannelWindEffect(true)
		this.nextChannelWindIsFirst = false
		if ANIMAL_PATH_CHANNEL_WIND_PERIOD <= 0.
			return
		let inst = this
		this.channelWindTimer = doPeriodically(ANIMAL_PATH_CHANNEL_WIND_PERIOD) (CallbackPeriodic c) ->
			inst.playNextChannelWindEffect()

	function playNextChannelWindEffect()
		if this.caster == null
			return
		this.playChannelWindEffect(this.nextChannelWindIsFirst)
		this.nextChannelWindIsFirst = not this.nextChannelWindIsFirst

	function playChannelWindEffect(boolean playFirst)
		if this.caster == null
			return
		let casterPos		= this.getCasterEffectPos()
		let animalPathPos	= this.getAnimalPathEffectPos()
		let modelPath = playFirst ? KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_1 : KUCHIYOSE_CHANNEL_WIND_MODEL_PATH_2
		let effectInstance1 = this.createChannelWindEffect(modelPath, casterPos)
		let effectInstance2 = this.createChannelWindEffect(modelPath, animalPathPos)
		if effectInstance1 != null
			this.channelWindEffects.add(effectInstance1)
		if effectInstance2 != null
			this.channelWindEffects.add(effectInstance2)

	function createChannelWindEffect(string modelPath, vec3 pos) returns effect
		let eff = addEffect(modelPath, pos)
		if eff != null
			eff.setTime(0.)
			eff.playAnimation(ANIM_TYPE_BIRTH)
		return eff

	function stopChannelWindEffects()
		if this.channelWindTimer != null
			destroy this.channelWindTimer
			this.channelWindTimer = null
		this.releaseAllChannelWindEffects()

	function releaseAllChannelWindEffects()
		if this.channelWindEffects == null
			return
		for fx in this.channelWindEffects
			releaseEffect(fx)
		destroy this.channelWindEffects
		this.channelWindEffects = null

	function finish(boolean success)
		if this.finished
			return
		this.finished = true
		this.stopChannelWindEffects()
		if this.caster != null and active.has(this.caster)
			active.remove(this.caster)
		if success
			this.startSuccessfulFinish()
		else
			this.cancelFinish()

	function startSuccessfulFinish()
		this.playCasterFinishAnimation()
		this.playAnimalPathFinishAnimation()
		let inst = this
		doAfter(ANIMAL_PATH_TELEPORT_DELAY) ->
			inst.completeSuccessfulFinish()

	function completeSuccessfulFinish()
		this.teleportAllies()
		this.cleanupScribble()
		this.caster = null
		destroy this

	function cancelFinish()
		this.removeAnimalPathImmediate()
		this.cleanupScribble()
		this.playCasterFinishAnimation()
		this.caster = null
		destroy this

	function playCasterFinishAnimation()
		let casterUnit = this.caster
		if casterUnit != null
			nullTimer() ->
				if casterUnit != null and casterUnit.isAlive()
					casterUnit..setAnimation(ANIMATION_END)..setTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)

	function spawnTeleportWindAt(vec2 pos)
		let fx = addEffect(KUCHIYOSE_TELEPORT_WIND_MODEL_PATH, pos.toVec3())
		if fx != null
			fx..setTimeScale(KUCHIYOSE_TELEPORT_WIND_TIME_SCALE)..playAnimation(ANIM_TYPE_BIRTH)
			doAfter(ANIMAL_PATH_TELEPORT_WIND_RELEASE_DELAY) ->
				releaseEffect(fx)

	function teleportAllies()
		if this.caster == null or not this.caster.isAlive()
			this.removeAnimalPathImmediate()
			return
		let origin = this.caster.getPos()
		teleportUnitToPoint(this.caster, this.targetPos)
		teleportUnitsInRangeToPoint(origin, ANIMAL_PATH_TELEPORT_RADIUS, this.targetPos, (unit u) -> this.shouldTeleport(u), ANIMAL_PATH_TELEPORT_SPREAD)
		this.spawnTeleportWindAt(this.targetPos)

	function shouldTeleport(unit u) returns bool
		if u == null or not u.isAlive()
			return false
		if u == this.caster
			return false
		if not u.isType(UNIT_TYPE_HERO)
			return false
		if not this.caster.isAllyOf(u)
			return false
		return true

	function playAnimalPathFinishAnimation()
		let summon = this.animalPath
		this.animalPath = null
		if summon == null
			return
		summon..setAnimation(ANIMATION_END)..setTimeScale(CASTER_FINISH_ANIMATION_TIME_SCALE)
		// doAfter(ANIMAL_PATH_FINISH_ANIMATION_DELAY) ->
			// summon.setAnimation(ANIMATION_END)
		doAfter(ANIMAL_PATH_LINGER_DURATION) ->
			if summon != null
				summon.remove()

	function removeAnimalPathImmediate()
		let summon = this.animalPath
		this.animalPath = null
		if summon != null
			summon.remove()

	function cleanupScribble()
		this.scribble1 = releaseEffect(this.scribble1)
		this.scribble2 = releaseEffect(this.scribble2)

	ondestroy
		this.stopChannelWindEffects()
		this.animalPath = null
		this.scribble1 = null
		this.scribble2 = null

function onChannel()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster == null
			return
		let targetPos = EventData.getSpellTargetPos()
		if not caster.getOwner().hasVisibility(targetPos)
			printTimedToPlayer("Target area is not visible.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if not targetPos.isTerrainWalkable()
			printTimedToPlayer("Cannot summon there.", SUMMON_CHANNEL_TIME, caster.getOwner())
			caster.issueImmediateOrder("stop")
			return
		if active.has(caster)
			active.get(caster).finish(false)
		let inst = new SummonAnimalPath(caster, targetPos)
		active.put(caster, inst)
		nullTimer() ->
			if caster != null
				caster..setAnimation(ANIMATION_CHANNEL)..setTimeScale(CASTER_CHANNEL_ANIMATION_TIME_SCALE)..queueAnimation("spell,one")

function onEnd()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).finish(false)

function onFinish()
	if GetSpellAbilityId() == NAGATO_SUMMON_ANIMAL_PATH
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).finish(true)

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEnd())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_FINISH, () -> onFinish())
