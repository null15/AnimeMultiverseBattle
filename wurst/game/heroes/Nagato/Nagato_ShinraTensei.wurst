package Nagato_ShinraTensei

import objectIDs
import Knockback
import Missiles
import ClosureForGroups
import ClosureTimers
import HashMap
import HashSet
import EntityManagement
import EntitySystem
import EffectsSystem
import SoundUtils
import SoundSystem
import TimeStop

constant SoundDefinition snd_ShinraTensei				= new SoundDefinition("Nagato\\Shinra Tensei\\ShinraTensei.mp3", false, true)
constant string SHINRA_TENSEI_FX						= "Nagato\\Shinra Tensei\\ShinraTensei.mdx"
constant string SHINRA_TENSEI_DIRT_FX					= "Nagato\\Shinra Tensei\\ShinraTenseiDirt.mdx"
constant string SHINRA_TENSEI_DUST_FX					= "Nagato\\Shinra Tensei\\DustWaveVersion2.mdx"
constant string SHINRA_TENSEI_BLAST_FX					= "Nagato\\Shinra Tensei\\ShinraTenseiBlast.mdx"
constant real SHINRA_TENSEI_PERIOD						= 0.1
constant real SHINRA_TENSEI_DURATION					= 2.
constant real SHINRA_TENSEI_RADIUS						= 400.
constant real SHINRA_TENSEI_DAMAGE_PER_TICK				= 1.
constant real SHINRA_TENSEI_KNOCKBACK_SPEED				= 800.
constant angle SHINRA_TENSEI_INITIAL_AIR_ANGLE			= (30)	.fromDeg()
constant real SHINRA_TENSEI_MAX_VERTICAL_SPEED			= 600.
constant real SHINRA_TENSEI_MAIN_Z_OFFSET				= -300.
constant real SHINRA_TENSEI_MAIN_SCALE					= 1.5
constant real SHINRA_TENSEI_DIRT_SCALE					= 0.1
constant real SHINRA_TENSEI_DIRT_TIME_SCALE				= 0.5
constant real SHINRA_TENSEI_DUST_SCALE					= 4.
constant real SHINRA_TENSEI_BLAST_SCALE					= 2.
constant real SHINRA_TENSEI_SOUND_RADIUS				= 700.
constant real SHINRA_TENSEI_COLLISION_RADIUS			= 128.
constant real SHINRA_TENSEI_COLLISION_DAMAGE			= 5.
constant real SHINRA_TENSEI_COLLISION_SLOW_FACTOR		= 0.6
constant real SHINRA_TENSEI_COLLISION_SLOW_DURATION		= 2.
constant int CASTER_ANIMATION_INDEX						= 12
constant real CASTER_ANIMATION_SPEED					= 0.5
constant HashMap<unit, ShinraTensei> active				= new HashMap<unit, ShinraTensei>()

function releaseEffect(EffectsEntity entity) returns EffectsEntity
	return destroyEffectEntity(entity)

class ShinraTensei
	unit caster
	CallbackPeriodic cb
	HashSet<unit> affected
	EffectsEntity shinraTensei
	EffectsEntity shinraTenseiDirt
	EffectsEntity dustWave
	EffectsEntity shinraTenseiBlast
	boolean effectsTimeStopped = false

	construct(unit caster)
		this.caster = caster
		this.affected = new HashSet<unit>
		this.createEffects()
		playSound(snd_ShinraTensei, this.getCasterEffectPos(), SHINRA_TENSEI_SOUND_RADIUS)
		this.cb = doPeriodically(SHINRA_TENSEI_PERIOD) (CallbackPeriodic c) ->
			this.tick()

	function createEffects()
		let casterPos = this.getCasterEffectPos()
		this.shinraTensei = addEffectEntity(SHINRA_TENSEI_FX, casterPos.add(0, 0, SHINRA_TENSEI_MAIN_Z_OFFSET))
		if this.shinraTensei != null
			this.shinraTensei.setScale(SHINRA_TENSEI_MAIN_SCALE)
		this.shinraTenseiDirt = addEffectEntity(SHINRA_TENSEI_DIRT_FX, casterPos)
		if this.shinraTenseiDirt != null
			this.shinraTenseiDirt.setScale(SHINRA_TENSEI_DIRT_SCALE)
			this.shinraTenseiDirt.setTimeScale(SHINRA_TENSEI_DIRT_TIME_SCALE)
			let dirtActor = this.shinraTenseiDirt.getActor()
			if dirtActor != null
				dirtActor.playAnimation(ANIM_TYPE_BIRTH)
		this.dustWave = addEffectEntity(SHINRA_TENSEI_DUST_FX, casterPos)
		if this.dustWave != null
			this.dustWave.setScale(SHINRA_TENSEI_DUST_SCALE)
			let dustActor = this.dustWave.getActor()
			if dustActor != null
				dustActor.playAnimation(ANIM_TYPE_BIRTH)
		this.shinraTenseiBlast = addEffectEntity(SHINRA_TENSEI_BLAST_FX, casterPos)
		if this.shinraTenseiBlast != null
			this.shinraTenseiBlast.setScale(SHINRA_TENSEI_BLAST_SCALE)
			let blastActor = this.shinraTenseiBlast.getActor()
			if blastActor != null
				blastActor.playAnimation(ANIM_TYPE_STAND)

	function tick()
		if this.caster == null or not this.caster.isAlive()
			this.stop()
			return
		this.updateEffectsTimeStop(this.caster.isTimeStopped())
		if not this.caster.isChannelingAbility(NAGATO_SHINRA_TENSEI)
			this.stop()
			return
		let consumed = this.caster.consumeChannelTime(NAGATO_SHINRA_TENSEI, SHINRA_TENSEI_PERIOD)
		if consumed <= 0.
			if this.caster.getChannelRemaining(NAGATO_SHINRA_TENSEI) <= 0.
				this.caster.finishChanneling(NAGATO_SHINRA_TENSEI)
				this.stop()
			return
		if this.caster.getChannelRemaining(NAGATO_SHINRA_TENSEI) <= 0.
			this.caster.finishChanneling(NAGATO_SHINRA_TENSEI)
			this.stop()
			return
		let casterPos = this.getCasterEffectPos()
		this.updateEffects(casterPos)
		let center = casterPos.toVec2()
		this.affectUnits(center)
		this.deflectMissiles(center)

	function getCasterEffectPos() returns vec3
		if this.caster == null
			return vec3(0, 0, 0)
		let casterEntity = this.caster.getEntity()
		return casterEntity != null ? casterEntity.getPos() : this.caster.getPos3Real()

	function updateEffects(vec3 casterPos)
		if this.shinraTensei != null
			this.shinraTensei.setPosition(casterPos.add(0, 0, SHINRA_TENSEI_MAIN_Z_OFFSET))
		if this.shinraTenseiDirt != null
			this.shinraTenseiDirt.setPosition(casterPos)
		if this.dustWave != null
			this.dustWave.setPosition(casterPos)
		if this.shinraTenseiBlast != null
			this.shinraTenseiBlast.setPosition(casterPos)

	function startEffectTimeStop(EffectsEntity entity)
		if entity == null
			return
		let fx = entity.getActor()
		if fx != null
			fx.startTimeStop()

	function stopEffectTimeStop(EffectsEntity entity)
		if entity == null
			return
		let fx = entity.getActor()
		if fx != null
			fx.stopTimeStop()

	function startEffectsTimeStop()
		this.startEffectTimeStop(this.shinraTensei)
		this.startEffectTimeStop(this.shinraTenseiDirt)
		this.startEffectTimeStop(this.dustWave)
		this.startEffectTimeStop(this.shinraTenseiBlast)

	function stopEffectsTimeStop()
		this.stopEffectTimeStop(this.shinraTensei)
		this.stopEffectTimeStop(this.shinraTenseiDirt)
		this.stopEffectTimeStop(this.dustWave)
		this.stopEffectTimeStop(this.shinraTenseiBlast)

	function updateEffectsTimeStop(boolean active)
		if active
			if not this.effectsTimeStopped
				this.effectsTimeStopped = true
				this.startEffectsTimeStop()
		else if this.effectsTimeStopped
			this.effectsTimeStopped = false
			this.stopEffectsTimeStop()

	function affectUnits(vec2 center)
		forUnitsInRange(center, SHINRA_TENSEI_RADIUS) (unit u) ->
			if this.caster.isEnemyOf(u)
				this.caster.damageTarget(u, SHINRA_TENSEI_DAMAGE_PER_TICK, ATTACK_TYPE_HERO)
				let direction = center.angleTo(u.getPos())
				this.applyKnockback(u, direction)
				this.checkCollision(u)

	function applyKnockback(unit u, angle direction)
		if this.affected.has(u)
			let velocity = Knockback3.getVel(u)
			let vertical = (velocity.z / ANIMATION_PERIOD).clamp(-SHINRA_TENSEI_MAX_VERTICAL_SPEED, SHINRA_TENSEI_MAX_VERTICAL_SPEED)
			let speed = SquareRoot(SHINRA_TENSEI_KNOCKBACK_SPEED * SHINRA_TENSEI_KNOCKBACK_SPEED + vertical * vertical)
			let air = vertical.atan2(SHINRA_TENSEI_KNOCKBACK_SPEED).fromRad()
			Knockback3.setVel(u, speed, direction, air)
		else
			Knockback3.setVel(u, SHINRA_TENSEI_KNOCKBACK_SPEED, direction, SHINRA_TENSEI_INITIAL_AIR_ANGLE)
			this.affected.add(u)

	function deflectMissiles(vec2 center)
		if this.caster == null
			return
		for m in Missiles.collection
			if m.owner != this.caster.getOwner()
				let missilePos = m.getPos().toVec2()
				if missilePos.distanceTo(center) <= SHINRA_TENSEI_RADIUS
					let target = missilePos + (missilePos - center)
					m.owner = this.caster.getOwner()
					m.deflect(target)

	function checkCollision(unit u)
		if not u.getPos().isTerrainWalkable()
			this.applyCollision(u)
			return
		forUnitsInRange(u.getPos(), SHINRA_TENSEI_COLLISION_RADIUS) (unit rod) ->
			if rod.getTypeId() == NAGATO_UZUMAKI_CHAKRA_ROD
				this.applyCollision(u)

	function applyCollision(unit u)
		if this.caster == null
			return
		this.caster.damageTarget(u, SHINRA_TENSEI_COLLISION_DAMAGE, ATTACK_TYPE_HERO)
		let baseSpeed = u.getMoveSpeed()
		u.setMoveSpeed(baseSpeed * SHINRA_TENSEI_COLLISION_SLOW_FACTOR)
		doAfter(SHINRA_TENSEI_COLLISION_SLOW_DURATION) ->
			if u != null
				u.setMoveSpeed(baseSpeed)

	function stop()
		if this.cb != null
			destroy this.cb
			this.cb = null
		if this.caster != null and active.has(this.caster)
			active.remove(this.caster)
			this.caster.clearChanneling(NAGATO_SHINRA_TENSEI)
		if this.effectsTimeStopped
			this.stopEffectsTimeStop()
			this.effectsTimeStopped = false
		if this.affected != null
			destroy this.affected
			this.affected = null
		this.shinraTensei = releaseEffect(this.shinraTensei)
		this.shinraTenseiDirt = releaseEffect(this.shinraTenseiDirt)
		this.dustWave = releaseEffect(this.dustWave)
		this.shinraTenseiBlast = releaseEffect(this.shinraTenseiBlast)
		destroy this

function onChannel()
	if GetSpellAbilityId() == NAGATO_SHINRA_TENSEI
		let caster = GetTriggerUnit()
		if caster == null
			return
		if active.has(caster)
			active.get(caster).stop()
		caster.startChanneling(NAGATO_SHINRA_TENSEI, SHINRA_TENSEI_DURATION)
		let inst = new ShinraTensei(caster)
		active.put(caster, inst)
		nullTimer() ->
			caster.setAnimation(CASTER_ANIMATION_INDEX)
			caster.setEntityTimeScale(CASTER_ANIMATION_SPEED)

function onStop()
	if GetSpellAbilityId() == NAGATO_SHINRA_TENSEI
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).stop()
		else if caster != null
			caster.clearChanneling(NAGATO_SHINRA_TENSEI)

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onStop())