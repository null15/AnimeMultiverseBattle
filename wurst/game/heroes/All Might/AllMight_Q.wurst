package AllMight_Q

import Entity
import abilityDefinitions
import SpellAPI
import ClosureForGroups

import Assets
import Missiles

function drawConeEdge(vec3 fromWhere, angle coneOrientation, real range)
	// simple missile along one cone edge
	let toWhere = fromWhere.toVec2().polarOffset(coneOrientation, range).withZ(fromWhere.z)
	let m = new Missiles(fromWhere, toWhere)
	m.setModel(Abilities.arrowMissile1)
	m.setSpeed(800.)
	m.launch()

function drawCone(vec3 fromWhere, angle coneOrientation, angle coneAngle, real range)
	// draw both edges
	drawConeEdge(fromWhere, coneOrientation - coneAngle, range)
	drawConeEdge(fromWhere, coneOrientation + coneAngle, range)

function onCast()
	if GetSpellAbilityId() == ALL_MIGHT_Q
		// Unit Variables
		let caster = GetTriggerUnit()
		let casterEntity = caster.getEntity()

		// "?" is a Ternary operator. We check if casterEntity is not null. If true, run the first expression, if false, run the last one. It works exactly like "if -> x else -> y"
		// First expression is the one before ":", so: casterEntity.getPos()
		// Second expression is the one after ":", so: caster.getPos3Real()
		let casterPosZ = casterEntity != null ? casterEntity.getPos() : caster.getPos3Real()
		let casterPos = casterPosZ.toVec2()
		let coneOrientation = casterPos.angleTo(EventData.getSpellTargetPos())
		let range = 900.
		let coneAngle = coneAngle(30)

		drawCone(casterPosZ, coneOrientation, coneAngle, range)
		forUnitsInRange(casterPos, range) (unit u) ->
			if u != caster and caster.isEnemyOf(u)
				let targetPos = u.getPos()
				if isPointInCone(casterPos, targetPos, range, coneOrientation, coneAngle)
					caster.damageTarget(u, 50, ATTACK_TYPE_HERO)

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT, () -> onCast())