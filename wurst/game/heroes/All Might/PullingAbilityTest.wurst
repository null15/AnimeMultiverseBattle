package PullingAbilityTest

import objectIDs
import Pull
import TimeStopSpell
import EntityManagement
import EntitySystem
import HashMap
import ClosureTimers

constant HashMap<unit, PullingAbilityTest> active	= new HashMap<unit, PullingAbilityTest>()
constant int CASTER_ANIMATION_INDEX					= 13
constant real CASTER_ANIMATION_SPEED				= 1.5
constant real CHANNEL_DURATION						= 6.

/*
My simple pull ability, compatible with time stop. We extend ChannelSpell, so we can use stuff from that class
Think of a class as a box tied to an instance. If we extend to another box, then it means we can use the toys in that box.

# Class explanation: Each object (ability in this case) has its own "box" when it gets created.
This box can hold data tied to that instance, depending on what variables you put in the box.
The box automatically cleans itself up when we no longer need it, to avoid leaks.

# Cloning / spell steal: Cloned abilities are just separate boxes, tracked independently.
Cooldown Reset on an ability and use it again directly after first cast, only means that the first instance is destroyed.
Then it creates the new instance (box) of the spell.

# Lingering effects: By default, re-casting destroys the old lingering instance (box) before creating a new one, so no stacking.

To-do: If we want lingering effect, we could simply have a boolean "linger", true means it can linger.
This means you can cast an ability, then cast it again and both "objects"/"instances" live together, until the lifespan is reached.
Or we can do e.g. store a list or key them by slot/ID
*/
class PullingAbilityTest extends ChannelSpell
	// this "box" variables
	unit caster
	unit target
	real elapsed
	Pull pull

	// construct means construction, and this is what we call when we create this "box"
	//
	// -> myBox = new PullingAbilityTest(parameter1, parameter2)
	//      ^      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
	//   variable    construct called, now we created this box
	//
	// Usually we create the box on spell cast, you can see it onChannel function at the bottom
	//
	// this <-- this instance of the object
	// this.caster = caster <-- now this instance of box's unit variable caster has the caster unit we put in the construct
	// and this variable can be used in the whole box now
	construct(unit caster, unit target)
		// super means we create another "box", in the class ChannelSpell that we extended at the top
		// basically just means "create this box too" that we extended to, "ChannelSpell" in this case
		super(caster, PULL_TEST_ABILITY, 0.03125)
		// the word "this" just means this current instance
		this.caster = caster
		this.target = target
		this.elapsed = 0.
		this.addTarget(target)
		pull = Pull.toUnit(target, caster, 128, 300)
		if this.pull == null
			if this.caster != null and this.caster.isAlive()
				this.caster.issueImmediateOrder("stop")
		else
			this.beginChannel(CHANNEL_DURATION)
			this.startTicking()

	// override means we overwrite the onChannelTick function in the ChannelSpell class we extended
	// we do this for our custom behaviour on each channel tick
	override function onChannelTick()
		if this.caster == null or not this.caster.isAlive()
			this.finishChannel(true)
			return
		if this.target == null or not this.target.isAlive()
			this.finishChannel(true)
			return
		let casterPos = this.caster.getEntity() != null ? this.caster.getEntity().getPos() : this.caster.getPos3Real()
		let targetPos = this.caster.getEntity() != null ? this.target.getEntity().getPos() : this.target.getPos3Real()
		if targetPos.distanceTo(casterPos) < 150
			this.finishChannel(true)
			return
		this.elapsed += this.getTickPeriod()
		print("Elapsed: " + this.elapsed.toString())

	// when channel finish, this runs
	override function onChannelFinish(boolean orderCaster) returns boolean
		if this.target != null
			Pull.stopActive(this.target)
		if orderCaster
			if this.caster != null and this.caster.isAlive()
				this.caster.issueImmediateOrder("stop")
		return orderCaster
	
	// for any cleanup related things
	override function onCleanup()
		if this.caster != null and active.has(this.caster)
			if active.get(this.caster) == this
				active.remove(this.caster)
		this.target = null
		this.pull = null
		this.caster = null
		this.elapsed = 0

function onChannel()
	if GetSpellAbilityId() == PULL_TEST_ABILITY
		let caster = GetTriggerUnit()
		let target = GetSpellTargetUnit()
		if active.has(caster)
			active.get(caster).stop(false)
		// Here we create the box, using its "construct" as explained above
		// the construct takes 2 parameters, so caster and target
		let pull = new PullingAbilityTest(caster, target)
		if pull != null and pull.isChannelActive()
			active.put(caster, pull)
			nullTimer() -> 
				caster
				..setAnimation(CASTER_ANIMATION_INDEX)
				..setEntityTimeScale(CASTER_ANIMATION_SPEED)
		else if pull != null
			destroy pull

function onEnd()
	if GetSpellAbilityId() == PULL_TEST_ABILITY
		let caster = GetTriggerUnit()
		if caster != null and active.has(caster)
			active.get(caster).finishChannel(false)

init
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, () -> onChannel())
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEnd())